#! /usr/bin/env python

# MailTask Alpha: The Email Manager
# Copyright (C) 2015  Patrick Simmons

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#Originally generated by flconvert

from collections import deque
from html2text import html2text
from request_structures import CaseInsensitiveDict,CaseInsensitiveDefaultDict

if __name__=="__main__":
    from fltk import *
    from FLTK_Advanced_Browser import *
else:
    def fl_alert(msg):
        print msg
    def Fl_flush():
        pass
    class empty:
        pass
    ui = empty()
    ui.block_w = empty()
    ui.block_w.show = ui.block_w.hide = Fl_flush
    
if __name__=="__main__":
    import mt_attache

import mt_utils
from ontask_messages import *

import base64
from copy import copy
try:
    import cPickle as pickle
except:
    import pickle
import email
import email.message
import email.parser
import email.utils
import functools
from html2text import html2text
import os
import shutil
import socket
import sys
import time
from select import select

#This would be too annoying if it had a long name
gfind = mt_utils.find
CaseInsensitiveList = mt_utils.CaseInsensitiveList

##To use in user agent
PROG_VERSION_STRING="MailTask/20151002"

##Constant tuple containing all user-modifiable headers.
# Other headers are ignored.
MODIFIABLE_HEADERS = CaseInsensitiveList(["From","Reply-To","To","Cc","Bcc","Subject", "X-MailTask-Date-Info", "X-MailTask-Completion-Status", "Date"])

##Constant tuple containing headers likely to have an email address in them
EMAIL_MODIFIABLE_HEADERS = CaseInsensitiveList(["From","Reply-To","To","Cc","Bcc"])

##Constant tuple containing all headers that should not be auto-deleted when replyifying a message
NON_DELETE_HEADERS = CaseInsensitiveList(MODIFIABLE_HEADERS + CaseInsensitiveList(["References","MIME-Version","Content-Type"]))

##Account Info list
account_info = []

##Address book dictionary
address_book = {}

#These vars keep track of whether it's okay to update the address book
addrbook_update_time=0
addrbook_pong_received=True

##Initialize account info list
# Format of file: five lines per account
# 0. Username
# 1. Password
# 2. IMAP server
# 3. SMTP server
# 4. From Address String
# All we care about is from address string
def initialize_account_info():
    aifile = open(os.path.join(cachedir,"ACCOUNT_INFO"))
    lines = aifile.readlines()
    lines = map(str.rstrip,lines)
    for i in range(1,len(lines),5):
        account_info.append(lines[i+4])

##Initialize address book dictionary
def initialize_addrbook():
    global address_book
    global addrbook_pong_received
    
    address_book = {}
    addrbook_pong_received=True
    
    addrbookfile = open(os.path.join(cachedir,"ADDRESSBOOK"))
    lines = addrbookfile.readlines()
    lines = map(str.rstrip,lines)
    for i in range(0,len(lines),2):
        address_book[lines[i]] = set(lines[i+1].split(","))

##Get email address from an email header string
def get_email_addr_from_header(f_header):
    components = f_header.split()
    handled=False
    for token in components:
        if token.find('@')!=-1:
            return token.lstrip('<').rstrip('>').lower()
    return ""

##Get nickname from email header string
def get_nick_from_header(f_header):
    if get_email_addr_from_header(f_header)!=f_header and f_header.find("<") not in (0,-1):
        to_return = f_header[0:f_header.find("<")].strip().strip("'\"").strip()
        if to_return!="":
            return to_return
    return None

##Returns True if any address book entry has the set containing only the passed string as its value
def addrbook_rev_email_set_cardinality_one_lookup(a_val):
    for entry in address_book:
        if address_book[entry]==set([a_val]):
            return True
    return False

##Return email address or addresses for address book entry
def addrbook_lookup(key):
    if key not in address_book:
        email = get_email_addr_from_header(key)
        nick = get_nick_from_header(key)
        if nick!=None and (nick not in address_book or email not in address_book[nick]) and nick.find(',')==-1 and nick.find('\n')==-1 and not addrbook_rev_email_set_cardinality_one_lookup(email) and nick!=email:
            c_state.update_addr_book(nick,email)
        return key
    to_return=""
    for entry in address_book[key]:
        if to_return!="":
            to_return+=","
        to_return+=entry
    return to_return

##Return address book entry/entries for email address/addresses
def addrbook_reverse_lookup(ikey):
    to_return=""
    bag_of_addresses = set()
    for entry_ in mt_utils.decomma(ikey).split(","):
        entry = mt_utils.recomma(entry_)
        if entry in address_book:
            bag_of_addresses |= address_book[entry]
        else:
            email = get_email_addr_from_header(entry)
            bag_of_addresses.add(email)
            nick = get_nick_from_header(entry)
            if nick!=None and (nick not in address_book or email not in address_book[nick]) and nick.find(',')==-1 and nick.find('\n')==-1 and not addrbook_rev_email_set_cardinality_one_lookup(email) and nick!=email:
                c_state.update_addr_book(nick,email)
    while len(bag_of_addresses):
        largest_subset=set()
        lsubkey = None
        for key in address_book:
            if address_book[key] <= bag_of_addresses and len(address_book[key]) > len(largest_subset):
                largest_subset = copy(address_book[key])
                lsubkey=key
        if len(largest_subset):
            if to_return!="":
                to_return+=","
            to_return+=lsubkey
            bag_of_addresses-=largest_subset
        else:
            break
    for addr in bag_of_addresses:
        if to_return!="":
            to_return+=","
        partial_nick=None
        l_smallest_superset=sys.maxint
        for entry in address_book:
            if addr in address_book[entry] and len(address_book[entry]) < l_smallest_superset:
                partial_nick = entry
                l_smallest_superset = len(address_book[entry])
        if partial_nick:
            to_return+=partial_nick+" <"+addr+">"
        else:
            to_return+=addr
    return to_return
            

##Get string appropriate for use in main editor, given a
# dictionary of the headers in an email message
def get_editor_str(current_headers):
    current_headers.sort(key=lambda x: gfind(MODIFIABLE_HEADERS,x[0]) if gfind(MODIFIABLE_HEADERS,x[0])!=-1 else sys.maxint)
    newtext=""
    divide_reached=False
    for header in current_headers:
        if not divide_reached and header[0] not in MODIFIABLE_HEADERS:
            divide_reached=True
            newtext+="\n\n\n"
        newtext+=header[0]+": "+header[1].replace("\r\n","\n")+"\n"
    return newtext

##Given an email address header dictionary, return a
# pretty-printable string representing what to include
# in the From/To column of the message list.
# Despite the name of the parameter, the parameter may
# but need not be a default dictionary
def get_prettyprintable_column_str(dd_hdrs):
    #print "in get_prettyprintable_column_str"
    s_params = get_email_send_parameters_from_msg(dd_hdrs)

    #Are we the sender?
    if int(s_params[0])!=len(account_info): #yes
        #Then we print the destination addresses
        
        #Color dictionary
        color_dict = { 4 : FL_DARK_GREEN, 5 : FL_DARK_BLUE, 6 : FL_DARK_BLUE,
                       7 : FL_DARK_BLUE, 2 : 89, 3 : FL_DARK_MAGENTA, 1 : FL_DARK_RED }

        #Single octal number To/Cc/Bcc
        color_selector = (("To" in dd_hdrs) << 2) + (("Cc" in dd_hdrs) << 1) + ("Bcc" in dd_hdrs)

        #No recipients, no column value
        if not color_selector:
            return ""

        #Otherwise, return appropriate colored string
        best_header = dd_hdrs['To'] if 'To' in dd_hdrs else dd_hdrs['Cc'] if 'Cc' in dd_hdrs else dd_hdrs['Bcc']
        return "@C"+repr(color_dict[color_selector])+"@."+addrbook_reverse_lookup(best_header)
    elif 'From' in dd_hdrs: #not the sender
        return "@."+addrbook_reverse_lookup(dd_hdrs['From'])
    else:
        return "@.Unknown"

def get_email_send_parameters_from_msg(msg):
    #Make sure msg contains "From" key; abort if not
    if "From" not in msg:
        return (repr(len(account_info)),[])
    
    #Get sending account id
    i=0
    while i<len(account_info):
        if get_email_addr_from_header(msg["From"])==get_email_addr_from_header(account_info[i]):
            break
        i+=1
    accid=repr(i)

    #Create list of destination addrs
    dest_addrs = []
    for header in ("To","Cc","Bcc"):
        if header in msg:
            for address in mt_utils.decomma(msg[header]).split(","):
                dest_addrs.append(get_email_addr_from_header(address))

    return (accid, dest_addrs)

##Get rid of newlines etc. and make all email addresses separated by ","
def sanitize_msg_headers(msg):
    for header in ("From","To","Cc","Bcc","Reply-To"):
        if header in msg:
            msg.replace_header(header,msg[header].replace("\r"," ").replace("\n"," ").replace("\t"," "))

class ClientUI:
    #Enumeration of possible left_browser update causes
    SELF_INDUCED=0
    STACK_PUSHED=1
    STACK_POPPED=2
    UI_INDUCED=3

    #Menus for emails/tasks
    EMAIL_MENU = ("Headers","Body","Attachments","Related")
    TASK_MENU = ("Metadata","Description","Drafts","Files","Related")
    
    ##left_browser_callback:
    # - handle updating upper text display, lower text display, stack.
    # - Create choices for left browser, select first one if choices changed
    # - Update nsync.cache appropriately.
    # - Refresh main browser, but not through main_browser_callback.
    @staticmethod
    def left_browser_callback(widget,cause=SELF_INDUCED):
        FOLDER_VIEW=1
        EMAIL_VIEW=2
        TASK_VIEW=3
        ATTACHMENT_VIEW=4

        #UI-induced callbacks should often be ignored
        if cause==ClientUI.UI_INDUCED and (not ui.left_browser.value() or ui.left_browser.value()==ui.lb_selected):
            return 1
        elif cause==ClientUI.UI_INDUCED:
            cause=ClientUI.SELF_INDUCED

        #Can't process click if main editor is open.
        if ui.main_editor.visible():
            if ui.left_browser.value()!=ui.lb_selected:
                fl_alert("Illegal action: editor open.")
                ui.left_browser.select(ui.lb_selected)
            return 1

        #Back up mb_selected in case we mess with main_browser later (likely)
        ui.mb_selected = ui.main_browser.value()

        #Are we displaying info in the left pane about a task or a message?
        if len(c_state.stack) < 3:
            current_view = FOLDER_VIEW
        elif c_state.stack[-2][0]==ClientState.ATTACHMENTS:
            current_view = ATTACHMENT_VIEW
        elif c_state.stack[-2][0]==ClientState.MESSAGE and c_state.stack[-2][1].get_content_type()=="multipart/x.mailtask":
            current_view = TASK_VIEW
        else:
            current_view = EMAIL_VIEW

        #We were actually clicked or have been ordered to do a simple refresh.
        if cause==ClientUI.SELF_INDUCED:
            #Were we actually clicked?  If so, handle thlat.
            if ui.left_browser.value()!=ui.lb_selected:
                #Save new selection value
                ui.lb_selected = ui.left_browser.value()

                #We need to update the stack to reflect the new selection
                if ui.lb_selected!=0: #just ignore the click if it's a deselection
                    if current_view!=ATTACHMENT_VIEW:
                        c_state.stack.pop()

                    if current_view==FOLDER_VIEW:
                        c_state.stack.append((ClientState.FOLDER,ui.left_browser.text(ui.lb_selected)))
                        ui.main_browser.deselect() #necessary or get_stacktop_uidpath() won't work
                    elif current_view==EMAIL_VIEW:
                        select_id = ClientUI.EMAIL_MENU.index(ui.left_browser.text(ui.lb_selected))
                        if select_id==0:
                            c_state.stack.append((ClientState.HEADERS,))
                        elif select_id==1:
                            todisplay = mt_utils.get_body(c_state.stack[-1][1])
                            if todisplay:
                                c_state.stack.append((ClientState.SUBMESSAGE,todisplay))
                            else:
                                c_state.stack.append((ClientState.ATTACHMENTS,))
                        elif select_id==2:
                            c_state.stack.append((ClientState.ATTACHMENTS,))
                        else: #select_id==3
                            c_state.stack.append((ClientState.RELATED,))
                    elif current_view==TASK_VIEW:
                        select_id = ClientUI.TASK_MENU.index(ui.left_browser.text(ui.lb_selected))

                        if select_id==0:
                            c_state.stack.append((ClientState.HEADERS,))
                        elif select_id==1:
                            todisplay = mt_utils.get_body(c_state.stack[-1][1])
                            if todisplay:
                                c_state.stack.append((ClientState.SUBMESSAGE,todisplay))
                            else:
                                c_state.stack.append((ClientState.ATTACHMENTS,))
                        elif select_id==2:
                            c_state.stack.append((ClientState.DRAFTS,))
                        elif select_id==3:
                            c_state.stack.append((ClientState.ATTACHMENTS,))
                        else: #select_id==4
                            c_state.stack.append((ClientState.RELATED,))
                
                #Refreshing main browser/display handled below
                
        else: #pushed or popped: handle updating LB options set lb selection to 1
            ui.left_browser.clear()

            if current_view==FOLDER_VIEW:
                for i in range(len(account_info)):
                    ui.left_browser.add(repr(i)+"/INBOX")
                    ui.left_browser.add(repr(i)+"/Sent")
                ui.left_browser.add("Tasks")
            elif current_view==EMAIL_VIEW:
                for line in ClientUI.EMAIL_MENU:
                    ui.left_browser.add(line)
            elif current_view==TASK_VIEW:
                for line in ClientUI.TASK_MENU:
                    ui.left_browser.add(line)
            else: #ATTACHMENT_VIEW
                ui.left_browser.add("Attachment")
        
        #Okay, now we just refresh the main display/browser and upper and
        #lower main display/browser headers.

        #Upper text display
        ui.upper_text_display.label(c_state.stack[0][1] if c_state.get_stacktop_uidpath()==None else c_state.get_stacktop_uidpath())

        #Lower text display
        if current_view==FOLDER_VIEW:
            if c_state.stack[0][1]=="Tasks":
                ui.lower_text_display1.label("Title")
                ui.lower_text_display2.label("Type")
            else:
                ui.lower_text_display1.label("Subject")
                ui.lower_text_display1.label("From/To")
            ui.lower_text_display3.label("Date")
        elif c_state.stack[-1][0]==ClientState.ATTACHMENTS:
            ui.lower_text_display1.label("Filename")
            ui.lower_text_display2.label("Type")
            ui.lower_text_display3.label("Date")
        else:
            ui.lower_text_display1.label("")
            ui.lower_text_display2.label("")
            ui.lower_text_display3.label("")

        #Refresh main browser/display:
        if c_state.stack[-1][0]==ClientState.FOLDER: #Email folder or task folder
            ui.main_display.hide()
            ui.main_browser.show()

            ui.main_browser.clear()

            horizon = ui.mb_selected + 100
            mb_counter = 0
            if c_state.stack[-1][1]=="Tasks":
                for entry in nsync.cache[c_state.stack[-1][1]]:
                    if mb_counter>=horizon:
                        break
                    mb_counter+=1

                    if c_state.show_completed_tasks or entry[1]['X-MailTask-Completion-Status']!="Completed":
                        tasktype = mt_utils.get_task_type(entry[1])
                        if tasktype=="Checklist":
                            dinfo = mt_utils.browser_time(entry[1]['Date'])
                        elif tasktype=="Deadline":
                            dinfo = "D:"+mt_utils.browser_time(entry[1]['X-MailTask-Date-Info'],"%m/%d/%y %H:%M")
                        else: #Meeting
                            mtimes = map(str.strip,entry[1]['X-MailTask-Date-Info'].split("/"))
                            mtime_s1 = 0
                            mtime_s2 = 0
                            if email.utils.parsedate_tz(mtimes[0])!=None:
                                mtime_s1 = time.localtime(email.utils.mktime_tz(email.utils.parsedate_tz(mtimes[0])))
                            if email.utils.parsedate_tz(mtimes[1])!=None:
                                mtime_s2 = time.localtime(email.utils.mktime_tz(email.utils.parsedate_tz(mtimes[1])))
                            ctime = time.localtime()

                            current_year = ctime.tm_year==mtime_s1.tm_year
                            current_month = ctime.tm_mon==mtime_s1.tm_mon
                            current_day = ctime.tm_mday==mtime_s1.tm_mday

                            match_year = mtime_s1.tm_year==mtime_s2.tm_year
                            match_month = mtime_s1.tm_mon==mtime_s2.tm_mon
                            match_day = mtime_s1.tm_mday==mtime_s2.tm_mday
                            match_hour = mtime_s1.tm_hour==mtime_s2.tm_hour
                            match_minute = mtime_s1.tm_min==mtime_s2.tm_min

                            fmatstr1 = "%m/%d/%y %H:%M"
                            if current_year:
                                fmatstr1 = fmatstr1.replace("/%y","")
                            if current_year and current_month:
                                fmatstr1 = fmatstr1.replace("%m/","")
                            if current_year and current_month and current_day:
                                fmatstr1 = fmatstr1.replace("%d ","")

                            fmatstr2 = "%m/%d/%y %H:%M"
                            if match_year:
                                fmatstr2 = fmatstr2.replace("/%y","")
                            if match_year and match_month:
                                fmatstr2 = fmatstr2.replace("%m/","")
                            if match_year and match_month and match_day:
                                fmatstr2 = fmatstr2.replace("%d ","")
                            if match_hour and match_minute:
                                fmatstr2 = fmatstr2.replace("%H:%M","")
                            elif match_hour:
                                fmatstr2 = fmatstr2.replace("%H","")
                            elif match_minute:
                                fmatstr2 = fmatstr2.replace("%M","")
                            fmatstr2 = fmatstr2.rstrip()
                            
                            dinfo=time.strftime(fmatstr1,mtime_s1)+"-"+time.strftime(fmatstr2,mtime_s2)
                        ui.main_browser.add("@."+entry[1]['Subject']+"\t@."+tasktype+"\t@."+dinfo)
            else: #non-Task folder
                for entry in nsync.cache[c_state.stack[-1][1]]:
                    if mb_counter>=horizon:
                        break
                    mb_counter+=1

                    dd_hdrs = CaseInsensitiveDefaultDict(lambda: "", entry[1])
                    ui.main_browser.add("@."+dd_hdrs["Subject"]+"\t"+get_prettyprintable_column_str(entry[1])+"\t@."+(mt_utils.browser_time(dd_hdrs["Date"]) if dd_hdrs["Date"]!="" else ""))
            if ui.mb_selected<=len(nsync.cache[c_state.stack[-1][1]]):
                ui.main_browser.select(ui.mb_selected)
            else:
                ui.main_browser.deselect()
                ui.mb_selected=0
        elif c_state.stack[-1][0]==ClientState.HEADERS: #viewing headers/metadata
            ui.main_display.show()
            ui.main_browser.hide()

            #Refresh display
            ui.main_buffer.text(get_editor_str(CaseInsensitiveList(c_state.stack[-2][1].items())))
        elif c_state.stack[-1][0]==ClientState.ATTACHMENTS: #viewing attachments
            ui.main_display.hide()
            ui.main_browser.show()

            #Refresh attachments
            nsync.cache["ATTACHMENTS"] = []

            ##Processes single submsg containing an attachment
            def process_single_submsg(component):
                if 'Content-Disposition' in component and component['Content-Disposition'].split(";")[0].strip().lower()=="attachment":
                    adate=component.get_param("modification-date",0,"Content-Disposition")
                elif "Date" in component:
                    adate=component["Date"]
                else:
                    adate="Unknown"
                adict = {}
                adict[None]=component
                for header in component.items():
                    adict[header[0]]=header[1]
                nsync.cache["ATTACHMENTS"].append((adate,adict))
            
            ##Walks subtree of attachments, appends all to "ATTACHMENTS" key in cache
            def walk_attachments(submsg):
                if not isinstance(submsg.get_payload(),str):
                    for component in submsg.get_payload():
                        if component.get_content_type().find("multipart/")==0:
                            for subsubmsg in component.get_payload():
                                walk_attachments(subsubmsg)
                        else:
                            process_single_submsg(component)
                else:
                    process_single_submsg(submsg)

            walk_attachments(c_state.stack[-2][1])
            nsync.cache["ATTACHMENTS"].sort(key=lambda k: k[0],reverse=True)

            #Update browser
            ui.main_browser.clear()
            for x in nsync.cache["ATTACHMENTS"]:
                ui.main_browser.add("@."+x[1][None].get_param("filename","","Content-Disposition")+"\t@."+x[1][None].get_content_type()+"\t@."+mt_utils.browser_time(x[1][None].get_param("modification-date","","Content-Disposition")))
            if ui.mb_selected<=len(nsync.cache["ATTACHMENTS"]):
                ui.main_browser.select(ui.mb_selected)
            else:
                ui.main_browser.deselect()
                ui.mb_selected=0
        elif c_state.stack[-1][0]==ClientState.SUBMESSAGE: #viewing body of message or single attachment
            ui.main_browser.hide()
            ui.main_display.show()
            
            #Extensible attachment handler
            ui.main_buffer.text(mt_attache.display_submessage(c_state.stack[-1][1]).replace("\r\n","\n"))
        elif c_state.stack[-1][0]==ClientState.RELATED:
            ui.main_display.hide()
            ui.main_browser.show()

            #Related view.  We CANNOT TRUST nsync.cache["RELATED"] here!
            #That information MAY BE STALE.  It is OUR JOB to update it!
            #So, let's do that now.

            #Get all folders, remove "RELATED", "DRAFTS", "ATTACHMENTS"
            cachekeys = nsync.cache.keys()
            for key in ("RELATED","DRAFTS","ATTACHMENTS"):
                if key in cachekeys:
                    cachekeys.remove(key)

            oldrelated = nsync.cache["RELATED"] if "RELATED" in nsync.cache else []
            nsync.cache["RELATED"] = []
            primary_msg = c_state.stack[-2][1]
            if 'References' in primary_msg:
                for rmid in mt_utils.get_related_ids(primary_msg):
                    record = mt_utils.search_cache(rmid,oldrelated)
                    if record!=None:
                        nsync.cache["RELATED"].append(record)
                        continue
                    for key in cachekeys:
                        record = mt_utils.search_cache(rmid,nsync.cache[key])
                        if record!=None:
                            record[1]["FOLDER"]=key
                            nsync.cache["RELATED"].append(record)
                            break

            #Okay, now let's sort the RELATED list
            nsync.cache["RELATED"].sort(key=lambda k: k[0],reverse=True)

            #Update browser
            ui.main_browser.clear()
            for entry_ in nsync.cache["RELATED"]:
                entry = CaseInsensitiveDefaultDict(lambda: None, entry_[1])
                ui.main_browser.add("@."+entry["Subject"]+"\t@."+entry["From"]+"\t@."+entry["Date"])
            if ui.mb_selected<=len(nsync.cache["RELATED"]):
                ui.main_browser.select(ui.mb_selected)
            else:
                ui.main_browser.deselect()
                ui.mb_selected=0
        else: #c_state.stack[-1][0]==ClientState.DRAFTS
            ui.main_display.hide()
            ui.main_browser.show()

            #Drafts view.  We CANNOT TRUST nsync.cache["DRAFTS"] here!
            #That information MAY BE STALE.  It is OUR JOB to update it!
            #So, let's do that now.
            nsync.cache["DRAFTS"]=[]
            primary_msg = c_state.stack[-2][1]

            for submsg in primary_msg.get_payload():
                epochtime = email.utils.mktime_tz(email.utils.parsedate_tz(submsg["Date"])) if submsg["Date"] and email.utils.parsedate_tz(submsg["Date"])!=None else 0
                if submsg.get_content_type()=="message/rfc822":
                    nsync.cache["DRAFTS"].append((epochtime,{ None: submsg }))

            #Sort DRAFTS list in cache
            nsync.cache["DRAFTS"].sort(key=lambda k: k[0],reverse=True)

            #Okay, done with that.  Update browser.
            ui.main_browser.clear()
            for entry_ in nsync.cache["DRAFTS"]:
                entry = entry_[1][None]
                ui.main_browser.add("@."+entry.get("Subject","")+"\t"+get_prettyprintable_column_str(entry)+"\t@."+entry.get("Date",""))
            if ui.mb_selected<=len(nsync.cache["DRAFTS"]):
                ui.main_browser.select(ui.mb_selected)
            else:
                ui.main_browser.deselect()
                ui.mb_selected=0

        print c_state.stack
        return 1

    ##main_browser_callback: called when main_browser enter pressed
    # add appropriate entries to stack, then call left_browser_callback
    @staticmethod
    def main_browser_callback():
        ui.mb_selected=ui.main_browser.value()

        if not ui.mb_selected:
            return 1
        
        if c_state.stack[-1][0]==ClientState.ATTACHMENTS: #attachments
            c_state.stack.append((ClientState.SUBMESSAGE,nsync.cache["ATTACHMENTS"][ui.mb_selected-1][1][None]))
        elif c_state.stack[-1][0]==ClientState.FOLDER: #folder
            uidpath = c_state.stack[0][1]+"/"+nsync.cache[c_state.stack[0][1]][ui.mb_selected-1][1]["UID"]
            c_state.stack.append((ClientState.MESSAGE,email.parser.Parser().parse(open(os.path.join(cachedir,uidpath))),uidpath))
            c_state.stack.append((ClientState.HEADERS,))
        elif c_state.stack[-1][0]==ClientState.RELATED: #RELATED view
            uidpath = nsync.cache["RELATED"][ui.mb_selected-1][1]["FOLDER"]+"/"+nsync.cache["RELATED"][ui.mb_selected-1][1]["UID"]
            c_state.stack.append((ClientState.MESSAGE,email.parser.Parser().parse(open(os.path.join(cachedir,uidpath))),uidpath))
            c_state.stack.append((ClientState.HEADERS,))
        elif c_state.stack[-1][0]==ClientState.DRAFTS: #DRAFTS view
            c_state.stack.append((ClientState.SUBMESSAGE,nsync.cache["DRAFTS"][ui.mb_selected-1][1][None]))
            c_state.stack.append((ClientState.HEADERS,))

        ui.left_browser_callback(ui.left_browser,ClientUI.STACK_PUSHED)
        return 1

    ##Turns cut object in browser gray
    def show_cut_highlighted(self):
        pass

    def make_window(self):

        #Create main window
        self.window = Fl_Double_Window(516, 221, 920, 675, "MailTask Alpha")
        self.window.resizable(self.window)

        self.left_browser = Fl_Select_Browser(0, 0, 165, 675)
        self.left_browser.type(2) #undocumented (wtf); makes selection highlight stick
        self.left_browser.when(FL_WHEN_CHANGED)
        self.left_browser.callback(lambda x: ClientUI.left_browser_callback(x,ClientUI.UI_INDUCED))
        self.left_browser.end()

        #Store the currently selected line in the left browser
        self.lb_selected = 1

        #Store the currently selected line in the main browser
        self.mb_selected = 0

        self.upper_text_display = Fl_Box(165, 0, 755, 40)
        self.upper_text_display.align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE)

        self.lower_text_display1 = Fl_Box(165, 40, 350, 40)
        self.lower_text_display1.box(FL_NO_BOX)
        self.lower_text_display1.align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE)

        self.lower_text_display2 = Fl_Box(515, 40, 250, 40)
        self.lower_text_display2.box(FL_NO_BOX)
        self.lower_text_display2.align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE)

        self.lower_text_display3 = Fl_Box(765, 40, 155, 40)
        self.lower_text_display3.box(FL_NO_BOX)
        self.lower_text_display3.align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE)

        self.main_editor = Fl_Text_Editor(165, 80, 755, 595)
        self.main_buffer = Fl_Text_Buffer()
        self.main_editor.buffer(self.main_buffer)
        self.main_editor.wrap_mode(3,0)
        self.main_editor.hide()
        self.main_editor.end()
        self.main_display = Fl_Text_Display(165,80,755,595)
        self.main_display.buffer(self.main_buffer)
        self.main_display.wrap_mode(3,0)
        self.main_editor.hide()

        #Whether main_editor or main_browser is visible depends on current mode

        #Custom browser class, so we can override keyboard handler
        #FLTK's documentation says a callback with FL_WHEN_ENTER_KEY_ALWAYS
        #should do the equivalent of this, but it doesn't, so we need to do
        #this instead.  FLTK's abysmal documentation strikes again.
        FLTK_Advanced_Parent = FLTK_Advanced_Browser(Fl_Select_Browser)
        class Custom_Main_Browser(FLTK_Advanced_Parent):
            def handle(self,etype):
                #Is this the correct event to be handling this?  If not, return 0
                if etype!=FL_KEYDOWN or Fl_event_key()!=FL_Enter or Fl_event_state(FL_CTRL):
                    return FLTK_Advanced_Parent.handle(self,etype)
                return ClientUI.main_browser_callback()

        self.main_browser = Custom_Main_Browser(165,80,755,595)
        self.main_browser.type(2) #stupid undocumented crap (see above)
        self.main_browser.column_widths((350,250,155))
        self.main_browser.hide()
        
        self.window.end()
        self.window.show()

        #Global shortcut handler
        Fl_add_handler(ClientState.shortcut_handler)
        
        #Blocking dialog box
        self.block_w = Fl_Single_Window(500,50)
        self.block_w.label("Please wait")
        self.block_w.set_modal()
        self.block_w.callback(lambda x: 1)
        self.boxblock = Fl_Box(0,0,500,50,"Server synchronization in progress.")
        self.boxblock.align(FL_ALIGN_INSIDE|FL_ALIGN_CENTER)
        self.block_w.end()


class ClientState:
    #Enumeration of possible stack type tags
    FOLDER=0
    MESSAGE=1
    HEADERS=2
    ATTACHMENTS=3
    SUBMESSAGE=4
    RELATED=5
    DRAFTS=6
    
    ##Class to use as type for clipboard
    # Type of value is true string when is_uidpath is false
    class Clipboard:
        UIDPATH=0
        TRUESTRING=1
        SUBMESSAGE=2
        
        def __init__(self,typ,val):
            self.type = typ
            self.value = val

    ##Initialize ClientState object
    def __init__(self):
        #Current view stack
        self.stack = []

        #Rate limit address book updates
        self.addrbook_rate_limit = 0

        #Do we show completed tasks in task view
        self.show_completed_tasks = False

        #Internal clipboard objects
        self.clipboard = ClientState.Clipboard(ClientState.Clipboard.TRUESTRING,"") #Contents of clipboard stored as MIME-encoded string
        self.deathslayer = lambda: None #callable that removes cut item; called upon paste
        #self.last_action_paste_from_copy = False #why is this here?

    ##Internal utility method to get single component of bottom-most message on the stack
    def get_stacktop_internal(self,component):
        for i in range(-1,-len(self.stack)-1,-1):
            if self.stack[i][0]==ClientState.MESSAGE:
                return self.stack[i][component]
        return None

    ##Utility method to handle get Message object of current top of stack
    # Specifically, the returned Message object should contain the entire
    # message that needs to be uploaded to the path from
    # get_stacktop_uidpath below.
    def get_stacktop_msg(self):
        return self.get_stacktop_internal(1)

    ##Utility method to handle getting UIDpath of current top of stack
    def get_stacktop_uidpath(self):
        return self.get_stacktop_internal(2)

    #Methods to handle shortcuts

    ##Handle editor state toggle
    def toggle_editor(self):
        if ui.main_editor.visible():
            ui.main_editor.hide()
            ui.main_display.show()
            if self.stack[-1][0]==ClientState.HEADERS:
                #Remove blank lines so parser won't screw up.
                headerlines = ui.main_buffer.text().splitlines()
                headerlines[:] = (line for line in headerlines if line.strip()!="")
            
                #Parse user's input
                n_message = email.parser.HeaderParser().parsestr("\n".join(headerlines))
                for header in MODIFIABLE_HEADERS:
                    if n_message[header]!=None:
                        if header in EMAIL_MODIFIABLE_HEADERS:
                            replacement_header=""
                            for entry in n_message[header].split(","):
                                if replacement_header!="":
                                    replacement_header+=","
                                replacement_header+=addrbook_lookup(entry)
                            if header in self.stack[-2][1]:
                                self.stack[-2][1].replace_header(header,replacement_header)
                            else:
                                self.stack[-2][1][header]=replacement_header
                        else:
                            del self.stack[-2][1][header]
                            self.stack[-2][1][header]=n_message[header]
                    else: #delete missing header
                        del self.stack[-2][1][header]
            else:
                self.stack[-1][1].set_payload(ui.main_buffer.text())

            #Send updated file to server
            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
        else:
            if self.stack[-1][0]==ClientState.FOLDER and self.stack[0][1].find("Tasks")!=0 or self.stack[-1][0]!=ClientState.FOLDER and self.get_stacktop_uidpath().find("Tasks")!=0:
                response = fl_ask("Warning: You are about to modify an IMAP message.  Are you sure you want to do this?")
                if not response:
                    return 1
            
            self.oldtext = ui.main_buffer.text()
            ui.main_display.hide()

            if self.stack[-1][0]==ClientState.HEADERS:
                #Buffer's text must use address book keys for modifiable headers
                header_dict = CaseInsensitiveDict(self.stack[-2][1].items())
                for header in MODIFIABLE_HEADERS:
                    if header in EMAIL_MODIFIABLE_HEADERS and header in header_dict:
                        header_dict[header] = addrbook_reverse_lookup(header_dict[header])

                #Now, we need to recreate the message's tuple list
                current_headers=CaseInsensitiveList()
                for header in header_dict:
                    current_headers.append((header,header_dict[header]))
                ui.main_buffer.text(get_editor_str(current_headers))
                ui.main_editor.show()
            else:
                ui.main_editor.show()
        return 1
            
    # def cancel_editor(self):
    #     if not ui.main_editor.visible():
    #         return 0

    #     ui.main_buffer.text(self.oldtext)
    #     ui.main_editor.hide()
    #     ui.main_display.show()
    #     return 1

    def cut_obj(self):
        if Fl_Widget.visible(ui.main_browser) and not ui.main_browser.value():
            return 0

        if ui.main_editor.visible():
            return 0

        #If we're not ultimately cutting a task, or from a task, error out
        if self.get_stacktop_uidpath()==None or self.get_stacktop_uidpath().find("Tasks")!=0:
            fl_alert("Can't cut from non-Task object.")
            return 1

        c_index = ui.main_browser.value() #1-based!
        if not ui.main_browser.value():
            fl_alert("Nothing selected.")
            return 1

        if self.stack[-1][0]==ClientState.DRAFTS:
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,nsync.cache["DRAFTS"][c_index-1][1][None])
            slayeruidpath = self.get_stacktop_uidpath()
            stacktopmsg = self.get_stacktop_msg()
            child = nsync.cache["DRAFTS"][c_index-1][1][None]
            def delcomponent():
                mt_utils.delete_payload_component(stacktopmsg,child)
                nsync.node_update(slayeruidpath,stacktopmsg.as_string())
            self.deathslayer = delcomponent            
        elif self.stack[-1][0]==ClientState.RELATED:
            selected_message_headers = nsync.cache["RELATED"][c_index-1][1]
            related_msg_uidpath = selected_message_headers["FOLDER"]+"/"+selected_message_headers["UID"]
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.UIDPATH,related_msg_uidpath)

            slayer_uidpath = self.get_stacktop_uidpath()
            slayer_origmsg = self.get_stacktop_msg()
            slayer_cutrelatedmid = mt_utils.get_message_id(selected_message_headers,selected_message_headers["FOLDER"])
            def slay_from_references():
                newreferencelist = mt_utils.get_related_ids(slayer_origmsg)
                index = gfind(newreferencelist,slayer_cutrelatedmid)
                if index==-1:
                    fl_alert("Warning: failed to delete cut message ID from related list of original message.")
                else:
                    del newreferencelist[index]
                    mt_utils.set_related_ids(slayer_origmsg,newreferencelist)
                    nsync.node_update(slayer_uidpath,slayer_origmsg.as_string())
            self.deathslayer = slay_from_references
        elif self.stack[-1][0]==ClientState.HEADERS:
            fl_alert("Email headers cannot be cut, only copied.")
        elif self.stack[-1][0]==ClientState.FOLDER: #folder view
            fl_alert("Can't cut tasks, only copy them.")
        elif self.stack[-1][0]==ClientState.ATTACHMENTS: #We are viewing attachments
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,nsync.cache["ATTACHMENTS"][c_index-1][1][None])

            def slay_from_attachments():
                mt_utils.delete_payload_component(self.stack[-2][1],nsync.cache["ATTACHMENTS"][c_index-1][1][None])
            self.deathslayer = slay_from_attachments
        else: #We are viewing a non-header component of a message
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,self.stack[-1][1])

            slayeruidpath = self.get_stacktop_uid()
            stacktopmsg = self.get_stacktop_msg()

            #Finding our direct parent is a little tricky.
            for i in range(-2,-len(self.stack)-1,-1):
                if self.stack[i][0]==ClientState.SUBMESSAGE or self.stack[i][0]==ClientState.MESSAGE:
                    parent = self.stack[i][1]
                    break
            
            child = self.stack[-1][1]
            def delcomponent():
                mt_utils.delete_payload_component(parent,child)
                nsync.node_update(slayeruidpath,stacktopmsg.as_string())
            self.deathslayer = delcomponent
        return 1

    def copy_obj(self):
        if Fl_Widget.visible(ui.main_browser) and not ui.main_browser.value():
            return 0

        if ui.main_editor.visible():
            return 0

        c_index = ui.main_browser.value() #1-based!
        self.deathslayer = lambda: None

        if self.stack[-1][0]==ClientState.RELATED: #RELATED view
            selected_message_headers = nsync.cache["RELATED"][c_index-1][1]
            related_msg_uidpath = selected_message_headers["FOLDER"]+"/"+selected_message_headers["UID"]
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.UIDPATH,related_msg_uidpath)
        elif self.stack[-1][0]==ClientState.DRAFTS: #DRAFTS view
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,nsync.cache["DRAFTS"][c_index-1][1][None])
        elif self.stack[-1][0]==ClientState.HEADERS:
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.TRUESTRING,ui.main_buffer.text())
        elif self.stack[-1][0]==ClientState.ATTACHMENTS: #We are viewing attachments
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,nsync.cache["ATTACHMENTS"][c_index-1][1][None])
        elif self.stack[-1][0]==ClientState.FOLDER: #folder view
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.UIDPATH,self.stack[0][1]+"/"+nsync.cache[self.stack[0][1]][c_index-1][1]["UID"])
        else: #Viewing non-header component of message
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,self.stack[-1][1])
        return 1

    def paste_obj(self):
        #If the editor is visible, the type of the clipboard object must be TRUESTRING
        if ui.main_editor.visible() and self.clipboard.type!=ClientState.Clipboard.TRUESTRING:
            fl_alert("Clipboard does not contain a string.")
            return 1
        elif not ui.main_editor.visible() and self.clipboard.type==ClientState.Clipboard.TRUESTRING:
            fl_alert("Clipboard contains a string, but the editor is not open.")
            return 1
        elif self.clipboard.type==ClientState.Clipboard.TRUESTRING:
            ui.main_editor.insert(self.clipboard.value)
        elif self.clipboard.type==ClientState.Clipboard.UIDPATH:
            if self.stack[-1][0]==ClientState.FOLDER: #folder view
                nsync.node_update(self.stack[-1][1]+"/NEWMESSAGE",open(os.path.join(cachedir,self.clipboard.value)).read())
            elif self.stack[-1][0]==ClientState.HEADERS: #This doesn't make sense
                return 0
            else: #RELATED message view, or single message view, or ATTACHMENTS view.  All do the same thing: encapsulate and attach the message whose UID is on the clipboard.
                msg = email.parser.Parser().parse(open(os.path.join(cachedir,self.clipboard.value)))

                if 'Message-ID' in msg:
                    rel_ids = mt_utils.get_related_ids(self.stack[-2][1])
                    rel_ids.append(mt_utils.get_message_id(msg,None))
                    mt_utils.set_related_ids(self.stack[-2][1],rel_ids)
                if self.stack[-1][0]!=ClientState.RELATED: #DRAFTS or single message view
                    mt_utils.attach_payload(self.stack[-2][1],msg)

                #Update modified message
                nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
                
            #refresh screen to show new message in related
            ui.left_browser_callback(ui.left_browser)
        else: #clipboard is SUBMESSAGE
            if self.stack[-1][0]==ClientState.RELATED: #RELATED message view
                fl_alert("Cannot paste submessage to related message view.")
                return 1
            elif self.stack[-1][0]==ClientState.DRAFTS: #DRAFTS message view
                self.stack[-2][1].attach(self.clipboard.value)
            elif self.stack[-1][0]==ClientState.ATTACHMENTS:
                mt_utils.attach_payload(self.stack[-2][1],self.clipboard.value)
            elif self.stack[-1][0]==ClientState.FOLDER: #folder view
                fl_alert("Cannot paste submessage to folder.")
                return 1
            else: #single message view (viewing headers or non-headers, no matter)
                mt_utils.attach_payload(self.stack[-2][1],self.clipboard.value)

            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())

        self.deathslayer()
        self.deathslayer = lambda: None
        return 1

    ##delete_obj: delete currently highlighted object from parent message,
    #             or currently highlighted message from parent folder
    def delete_obj(self):
        if ui.main_editor.visible() or Fl_Widget.visible(ui.main_browser) and not ui.main_browser.value():
            return 0

        if self.stack[-1][0]==ClientState.FOLDER and self.stack[0][1].find("Tasks")!=0 or self.stack[-1][0]!=ClientState.FOLDER and self.get_stacktop_uidpath().find("Tasks")!=0:
            response = fl_ask("Warning: You are about to modify an IMAP folder.  Are you sure you want to do this?")
            if not response:
                return 1
        
        b_index = ui.main_browser.value()
        
        if self.stack[-1][0]==ClientState.RELATED: #RELATED message view
            s_headers = nsync.cache["RELATED"][b_index-1][1]
            relmID_to_delete = s_headers["Message-ID"].strip()
            newreferencelist = mt_utils.get_related_ids(self.stack[-2][1])
            index = gfind(newreferencelist,relmID_to_delete)
            if index==-1:
                fl_alert("Warning: failed to delete cut message ID from related list of original message.")
            else:
                del newreferencelist[index]
                mt_utils.set_related_ids(self.stack[-2][1],newreferencelist)
                nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
            ui.left_browser_callback(ui.left_browser)
        elif self.stack[-1][0]==ClientState.DRAFTS: #"DRAFTS"
            draft_to_delete = nsync.cache["DRAFTS"][b_index-1][1][None]
            payload = self.stack[-2][1].get_payload()
            del payload[payload.index(draft_to_delete)]
            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
        elif self.stack[-1][0]==ClientState.HEADERS:
            fl_alert("Cannot delete email headers.")
        elif self.stack[-1][0]==ClientState.ATTACHMENTS:
            mt_utils.delete_payload_component(self.stack[-2][1],nsync.cache["ATTACHMENTS"][b_index-1][1][None])
            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
        elif self.stack[-1][0]==ClientState.FOLDER: #folder view
            nsync.node_update(self.stack[0][1]+"/"+nsync.cache[self.stack[0][1]][b_index-1][1]["UID"],"")
        else: #viewing non-header component of message
            payload = self.stack[-2][1].get_payload()
            if not isinstance(payload,list):
                fl_alert("Cannot delete sole component of message body")
            mt_utils.delete_payload_component(self.stack[-2][1],self.stack[-1][1])

            #This is complicated by the fact that we may be viewing a draft message
            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
            ui.left_browser_callback(ui.left_browser)
        return 1

    def pop_view(self):
        if ui.main_editor.visible():
            response = fl_ask("The editor is open.  Are you sure you want to cancel any unsaved edits?")
            
            if not response:
                return 1

            ui.main_editor.hide()
            ui.main_buffer.text(self.oldtext)
            ui.main_display.show()
            ui.left_browser_callback(ui.left_browser)
            return 1

        #Can't pop if already at top of stack
        if len(self.stack)==1:
            return 1

        #Still here, no editor open and not at top of stack
        self.stack.pop()
        if self.stack[-1][0]!=ClientState.ATTACHMENTS: #We were NOT viewing an attachments, so pop again.
            self.stack.pop()
        ui.left_browser_callback(ui.left_browser,ClientUI.STACK_POPPED)
        return 1

    ##Must be viewing a draft message
    # After sending message, delete draft message from parent task, add its Message-ID
    # to parent task, and, if there are no remaining draft messages in task, mark the
    # task completed.
    # Service client will unmark completed task when new message comes in referencing
    # any emails associated with task.
    def send_email(self):
        if ui.main_editor.visible():
            fl_alert("Must close editor before sending mail.")
            return 1
        
        inside_draft = False
        if self.stack[-1][0]==ClientState.DRAFTS: #In DRAFTS view
            b_index = ui.main_browser.value()
            if not b_index:
                fl_alert("No message selected.")
                return 1

            draft_to_send = nsync.cache["DRAFTS"][b_index-1][1][None]
            parent_of_draft = self.stack[-2][1]
            parent_uid = self.stack[-2][2]
        elif len(self.stack)>3 and self.stack[-3][0]==ClientState.DRAFTS:
            inside_draft = True
            draft_to_send = self.stack[-2][1]
            parent_of_draft = self.stack[-4][1]
            parent_uid = self.stack[-4][2]
        else:
            fl_alert("Not viewing a draft message.")
            return 1

        #Do we have any recipients?
        s_params = get_email_send_parameters_from_msg(draft_to_send)
        if int(s_params[0])==len(account_info) or not len(s_params[1]):
            fl_alert("Incomplete or invalid message headers.")
            return 1

        #Still here, we've got draft_to_send, parent_of_draft, and parent_uid
        #Set date to current time
        if "Date" in draft_to_send:
            draft_to_send.replace_header("Date",email.utils.formatdate(localtime=True))
        else:
            draft_to_send["Date"]=email.utils.formatdate(localtime=True)
        
        #Send actual message
        sent_mid = nsync.send_email(draft_to_send)

        #Delete draft email from parent task
        parent_payload = parent_of_draft.get_payload()
        todelete_idx = gfind(parent_payload,draft_to_send)
        if todelete_idx==-1:
            fl_alert("System error: draft not found in parent.")
            return 1
        del parent_payload[todelete_idx]

        #Add sent MID to related messages of parent task
        if parent_uid!="Tasks/BLACKHOLE":
            relmids = mt_utils.get_related_ids(parent_of_draft)
            relmids.append(sent_mid)
            mt_utils.set_related_ids(parent_of_draft,relmids)
        
        #Update parent task
        nsync.node_update(parent_uid,parent_of_draft.as_string())

        #If we're inside the message we're sending, pop our stack.
        if inside_draft:
            self.stack.pop() #Interior component of sent message
            self.stack.pop() #Message itself

            #We're done now; we're viewing the DRAFTS section of the task
            #we just sent.  Unless the task is BLACKHOLE.  Then pop the
            #task off the stack as well.
            if self.stack[-2][2]=="Tasks/BLACKHOLE":
                self.stack.pop()
                self.stack.pop()

        #Refresh screen
        ui.left_browser_callback(ui.left_browser,ClientUI.STACK_POPPED if inside_draft else ClientUI.SELF_INDUCED)

    ##Send every draft email associated with task
    # Must have task selected or be viewing task
    def send_task(self):
        if self.stack[0][1]!="Tasks":
            fl_alert("Not viewing tasks.")
            return 1

        if len(self.stack) > 3:
            fl_alert("There's a task on the stack, but you're somewhere else.")
            return 1

        tval = ui.main_browser.value()
        if not tval:
            fl_alert("No task highlighted.")
            return 1
        taskuid = "Tasks/"+nsync.cache["Tasks"][tval-1][1]["UID"]

        if len(self.stack)==1:
            taskmsg = email.parser.Parser().parse(open(os.path.join(cachedir,taskuid)))
        else:
            taskmsg = self.stack[1][1] #NOT [-1][1]: this isn't a bug (well, I don't think it is)

        payload = taskmsg.get_payload()
        
        i=0
        while i<len(payload):
            draft_to_send = payload[i]
            if not draft_to_send["Content-Type"]=="message/rfc822":
                i+=1
                continue

            #Set date to current time
            if "Date" in draft_to_send:
                draft_to_send.replace_header("Date",email.utils.formatdate(localtime=True))
            else:
                draft_to_send["Date"]=email.utils.formatdate(localtime=True)

            sent_mid = nsync.send_email(draft_to_send)
            del payload[i]
            taskmsg.set_payload(payload)

            #Add sent MID to related messages of parent task
            relmids = mt_utils.get_related_ids(taskmsg)
            relmids.append(sent_mid)
            mt_utils.set_related_ids(taskmsg,relmids)

            nsync.node_update(taskuid,taskmsg.as_string())

        #Refresh screen
        ui.left_browser_callback(ui.left_browser)
        
        return 1

    ##Turn a message into a "reply all"
    def make_reply_all(self):
        hdictstr='{ "To" : to_set, "Cc" : cc_set, "Bcc" : bcc_set }'
        return self.make_reply_internal(hdictstr)
    
    ##Turn a message into a "reply to sender"
    def make_reply_sender(self):
        hdictstr='{ "To" : unused_set, "Cc" : unused_set, "Bcc" : unused_set }'
        return self.make_reply_internal(hdictstr)
    
    ##Turn a message into a reply.
    # Must be viewing headers of draft message for this to work
    def make_reply_internal(self,header_dictstr):
        if len(self.stack) < 5 or self.stack[-1][0]!=ClientState.HEADERS or self.stack[-3][0]!=ClientState.DRAFTS:
            fl_alert("Refusing to replyify non-draft message.")
            return 1

        #Just an alias, for clarification
        msg=self.stack[-2][1]

        #Sanitize headers (no newlines and tabs; comma separators only)
        sanitize_msg_headers(msg)
        
        #Backup Message-ID if exists
        if 'Message-ID' in msg:
            backup_mid = msg['Message-ID']
        else:
            backup_mid = ""
        
        #Delete extraneous headers
        for header_ in msg.items():
            header = header_[0]
            if header not in NON_DELETE_HEADERS:
                del msg[header]

        #Okay, now replyify the message.
        #Replyification sets
        to_set = set()
        cc_set = set()
        bcc_set = set()
        unused_set = set()
        
        #Replyification dicts
        header_dict=eval(header_dictstr)
        recon_dict={ "To" : to_set, "Cc" : cc_set, "Bcc" : bcc_set }
        
        #Replyified from header
        if "From" in msg:
            oldfrom = msg["From"]
        elif "Reply-To" in msg:
            oldfrom = msg["Reply-To"]
        else:
            oldfrom = "a dark and mysterious stranger"

        def add_if_not_already_in_set(set,addr):
            for item in to_set:
                if get_email_addr_from_header(item)==get_email_addr_from_header(email):
                    return
            set.add(get_email_addr_from_header(addr))

        from_addr=""
        for header in ("From","To","Cc","Bcc","Reply-To"):
            if header not in msg:
                continue

            if header in ("From","Reply-To"):
                for email in mt_utils.decomma(msg[header]).split(","):
                    add_if_not_already_in_set(to_set,email)
            else:
                for email in mt_utils.decomma(msg[header]).split(","):

                    #Check if this address is in account_info
                    address_is_us=False
                    for acct_from in account_info:
                        if get_email_addr_from_header(acct_from)==get_email_addr_from_header(email):
                            address_is_us=True
                            
                            #Set our from address, if we don't have one.
                            if from_addr=="":
                                from_addr=email

                    if not address_is_us:
                       add_if_not_already_in_set(header_dict[header],email)

        #If we can't tell what account to use for from address, use account 0.
        if from_addr=="":
            from_addr=account_info[0]
        #Now, reconstruct headers
        del msg["From"]
        msg["From"]=from_addr

        #Replyify To,Cc,Bcc
        for header in ("To","Cc","Bcc"):
            del msg[header]
            if len(recon_dict[header]):
                msg[header] = ",".join(recon_dict[header])

        #Now replyify the References header
        if 'References' in msg:
            idlist = mt_utils.get_related_ids(msg)
            idlist.append(backup_mid)
            mt_utils.set_related_ids(msg,idlist)
        else:
            msg['References']=backup_mid

        #Good.  Now, replyify body.
        body = mt_utils.get_body(msg)

        #VILE CREATURE, THOU DURST CALL UPON ME?
        #WALK NO MORE, PERVERSION OF NATURE!
        if body.get_content_type()=="text/html":
            payload = mt_attache.text_html(body,mt_attache.FLTK_ENCODING)
        else:
            payload = mt_attache.text_plain(body,mt_attache.FLTK_ENCODING)
        del body['Content-Type']
        body['Content-Type']="text/plain"
        del body['Content-Transfer-Encoding']
        body['Content-Transfer-Encoding']='8BIT'
        body.set_payload(payload)

        #Delete attachments etc.
        msg.set_payload([body])

        #Delete goofy headers
        for header in body.items():
            if header[0] not in ('Content-Type','MIME-Version'):
                del body[header[0]]
        
        #Quote ("With "> ") the previous body.
        body_to_quote = body.get_payload(decode=True)
        lines = body_to_quote.splitlines()
        lines = map(lambda x: "> "+x,lines)
        lines.insert(0,"On "+msg["Date"]+", "+oldfrom+" wrote:")
        body.set_payload("\n".join(lines)+"\n"+("-- \n"+signature+"\n" if signature!="" and body_to_quote.find(signature)==-1 else ""))
            
        #Update parent task on server
        nsync.node_update(self.get_stacktop_uidpath(),self.stack[-4][1].as_string())

    ##Load a file attachment to the clipboard
    # Always encoded as base64
    def load_file_to_clipboard(self):
        fname=fl_file_chooser("Select an attachment","*","")
        if fname==None:
            return 1
        try:
            filetext=open(fname).read()
        except IOError:
            fl_alert("No such file")
            return 1
        msg = email.message.Message()
        msg['Content-Type']=mt_utils.get_mime_type(fname)
        msg['Content-Transfer-Encoding']="base64"
        msg.add_header('Content-Disposition',"attachment",filename=(fname if fname.rfind("/")==-1 else fname[fname.rfind("/")+1:]))
        msg.set_payload(base64.b64encode(filetext))
        self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,msg)
        return 1

    ##Create a new task.
    # This will not work unless you are in Task list view.
    def new_task(self):
        #In "task list" view
        if len(self.stack)==1 and self.stack[0][1]=="Tasks":
            newtask=email.message.Message()
            nt_body = email.message.Message()
            nt_body['Content-Type'] = "text/plain"
            nt_body.set_payload("")
            mt_utils.attach_payload(newtask,nt_body)
            newtask['Content-Type']="multipart/x.MailTask"
            newtask['Date']=email.utils.formatdate(localtime=True)
            newtask['Subject'] = "New Task"
            newtask['X-MailTask-Type'] = "Checklist"
            newtask['X-MailTask-Completion-Status'] = "Incomplete"
            newtask['X-MailTask-Virgin'] = "Yes"
            nsync.node_update("Tasks/NEWMESSAGE",newtask.as_string())
        else:
            fl_alert("Must be viewing Task list when creating new tasks.")
    
    ##Create new message
    def compose(self,accid):
        if ui.main_editor.visible():
            fl_alert("Cannot compose new message while editor active.")
            return 1

        #Create new draft message
        newmsg = email.message.Message()
        newmsg['Content-Type'] = "message/rfc822"
        newmsg['Content-Transfer-Encoding']='8BIT'
        newmsg['From'] = account_info[accid]

        #Create body for new draft message
        nm_body = email.message.Message()
        nm_body['Content-Type'] = "text/plain" #If you want HTML, repent your sins.
        nm_body.set_payload("-- \n"+signature if signature!="" else "")

        #Attach body to message
        newmsg.attach(nm_body)

        #Convenience hack: If we try to compose a message when we're not
        #in the DRAFTS view of a Task, put us in the BLACKHOLE task and
        #launch composition interface from there.
        if not (self.stack[0][1]=="Tasks" and self.stack[-1][0]==ClientState.DRAFTS):
            self.stack.append((ClientState.MESSAGE,email.parser.Parser().parse(open(os.path.join(cachedir,"Tasks/BLACKHOLE"))),"Tasks/BLACKHOLE"))
            self.stack.append((ClientState.DRAFTS,))

        #Put new message on stack, set us to view HEADERS first
        mt_utils.attach_payload(self.get_stacktop_msg(),newmsg)
        self.stack.append((ClientState.SUBMESSAGE,newmsg))
        self.stack.append((ClientState.HEADERS,))

        #Refresh screen
        ui.left_browser_callback(ui.left_browser,ClientUI.STACK_PUSHED)

    ##Toggle whether completed tasks are visible
    def toggle_completed_task_visibility(self):
        self.show_completed_tasks = not self.show_completed_tasks
        print "Show completed tasks: "+repr(self.show_completed_tasks)
        return 1

    ##Toggle forced completion status of task
    def toggle_current_task_completion(self):
        if len(self.stack)!=1 or self.stack[-1][1]!="Tasks" or not ui.main_browser.value():
            fl_alert("Force task completion not valid in this view.")

        msg = email.parser.Parser().parse(open(os.path.join(cachedir,self.stack[0][1],nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1]["UID"])))
        if 'X-MailTask-Forced-Complete' in msg:
            del msg['X-MailTask-Forced-Complete']
        else:
            msg['X-MailTask-Forced-Complete'] = "Yes"
        nsync.node_update(self.stack[0][1]+"/"+nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1]["UID"],msg.as_string())
        return 1

    ##Make task's time be now
    def nowify(self):
        if len(self.stack)!=1 or self.stack[-1][1]!="Tasks" or not ui.main_browser.value():
            fl_alert("Updating date field not allowed in this view.")

        msg = email.parser.Parser().parse(open(os.path.join(cachedir,self.stack[0][1],nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1]["UID"])))
        del msg['Date']
        msg['Date'] = email.utils.formatdate(localtime=True)
        nsync.node_update(self.stack[0][1]+"/"+nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1]["UID"],msg.as_string())
        return 1

    ##Rename an attachment
    def rename_attachment(self):
        if self.stack[-1][0]!=ClientState.ATTACHMENTS or not ui.main_browser.value():
            fl_alert("No attachment selected.")

        attach_obj = nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1][None]
        newname = fl_input("Enter new name for attachment:",attach_obj.get_filename())
        if newname!=None:
            del attach_obj["Content-Disposition"]
            attach_obj.add_header("Content-Disposition","attachment",filename=newname)
    
    ##Update address book
    def update_addr_book_ui(self):
        nick=fl_input("Enter name of address book entry:")
        if nick==None:
            return 1
        current_val = addrbook_lookup(nick) if nick in address_book else ""
        newval = fl_input("Enter new value for address book entry "+nick,current_val)
        self.update_addr_book(nick,newval,True)
        return 1

    ##Update address book (internal)
    def update_addr_book(self,nick,newval,force=False):
        cur_time = time.time()
        if self.addrbook_rate_limit+1 > cur_time and not force:
            return 1
        self.addrbook_rate_limit = cur_time
        if newval!=None and newval!="":
            def mutator(old_val):
                #Do nothing if we're already in the address book
                if nick in address_book and newval in address_book[nick]:
                    return old_val

                old_addrbook = old_val.splitlines()
                old_nick_pos = mt_utils.find(old_addrbook,nick)

                #Check for duplicate addition to existing nick entry
                if old_nick_pos!=-1:
                    old_vals = set(old_addrbook[old_nick_pos+1].split(","))
                    if newval in old_vals:
                        return old_val

                #Check for cardinality one set containing newval
                if mt_utils.find(old_addrbook,newval)!=-1:
                    return old_val

                #Perform the addition
                if nick not in address_book:
                    return old_val+nick+"\n"+newval+"\n"
                old_addrbook[old_addrbook.index(nick)+1]+=","+newval
                return "\n".join(old_addrbook)+"\n"
        elif nick in address_book:
            def mutator(old_val):
                old_addrbook = old_val.splitlines()
                idx = mt_utils.find(old_addrbook,nick)
                if idx==-1:
                    return old_val
                del old_addrbook[idx:(idx+2)]
                return "\n".join(old_addrbook)+"\n"
        else:
            return 1

        nsync.atomic_update("ADDRESSBOOK",mutator)
        return 1
    
    ##Use as handler for client keyboard shortcuts
    # Fl_event_key() and Fl_event_state() should be used to find out what shortcut
    @staticmethod
    def shortcut_handler(e_type):
        if e_type!=FL_SHORTCUT:
            return 0

        modified_event_state = Fl_event_state()&~FL_NUM_LOCK&~FL_SCROLL_LOCK&~FL_CAPS_LOCK

        #Notes:
        #- No message may be composed except if it is part of a task.
        #- For ease-of-use, support copying subject from message inside of a
        #  task to be the subject of the task itself.  This should be done
        #  when popping out of a task.
        #- Probably need get_stacktop_uid() function equivalent for message
        #  objects.
        
        valid_shortcuts = { (FL_CTRL,ord('e')) : c_state.toggle_editor,
                            (FL_CTRL,ord('w')) : c_state.cut_obj,
                            (FL_ALT,ord('w')) : c_state.copy_obj,
                            (FL_CTRL,ord('y')) : c_state.paste_obj,
                            (FL_CTRL,ord('k')) : c_state.delete_obj,
                            (0,FL_Escape) : c_state.pop_view,
                            (FL_CTRL,FL_Enter) : c_state.send_email,
                            (FL_CTRL|FL_ALT,ord('t')) : c_state.send_task,
                            (FL_CTRL,ord('r')) : c_state.make_reply_all,
                            (FL_CTRL,ord('j')) : c_state.make_reply_sender,
                            (FL_CTRL,ord('a')) : c_state.load_file_to_clipboard,
                            (FL_CTRL,ord('n')) : c_state.new_task,
                            (FL_ALT,ord('v')) : c_state.toggle_completed_task_visibility,
                            (FL_ALT,ord('c')) : c_state.toggle_current_task_completion,
                            (FL_ALT,ord('r')) : c_state.rename_attachment,
                            (FL_ALT,ord('a')) : c_state.update_addr_book_ui,
                            (FL_ALT,ord('n')) : c_state.nowify }

        #These shortcuts go to the message composition interface.
        #Dynamically generated: Ctrl-0 uses account 0 as from, etc.
        for i in range(len(account_info)):
            valid_shortcuts[(FL_CTRL,ord(repr(i)))] = functools.partial(c_state.compose,i)

        if (modified_event_state,Fl_event_key()) not in valid_shortcuts:
            return 0

        #Switch based on event key, do your thing
        return valid_shortcuts[(modified_event_state,Fl_event_key())]()

class ClientNetSync:
   ##initialize nsync
   #NOTE: For all methods in queue, you must call flush afterwards
    def __init__(self):
        #Queue of server updates
        self.server_update_queue = deque()

        self.connmanager()
        
        #In-memory cache of emails/tasks
        #In the "Tasks" folder, the value for the "UID" key is the
        #filename of the Task, which is a ctime-style timestamp.
        #There is a special "RELATED" key which holds a list
        #corresponding to the items in the "RELATED" view of an email.
        #It contains additional key "FOLDER".
        #There is a special "DRAFTS" key which holds a list
        #corresponding to the items in the "DRAFTS" view of a task.
        #It does not contain a UID key but contains the additional key
        #None, which is associated with a Message object representing
        #the entire draft email.
        #There is a special "ATTACHMENTS" key which holds a list
        #corresponding to the items in the "ATTACHMENTS" view of a task
        #or message.  It does not contain a UID key but contains the
        #additional key None, which is associated with a Message object
        #representing the attachment.
        #The items in the dictionary in the tuple in the array
        #attached to this key:
        #Format:
        # { "Account/Folder" :
        #    [ (Date, { "Header" : "value", "UID" : "value" }), ...] }
        #Each list is sorted in descending order by Date.  The date is
        #parsed from the email headers using email.utils.parsedate
        self.cache = {}

    ##initialize_cache: Send folder_update_req requests for all folders, including Tasks
    def initialize_cache(self):
        for i in range(len(account_info)):
            self.folder_update_req(repr(i)+"/INBOX")
            self.folder_update_req(repr(i)+"/Sent")
        self.folder_update_req("Tasks")

    ##add_to_cache: add a message or task to our local client cache, by default both in-memory and on-disk
    def add_to_cache(self,filename,contents,add_to_disk=True):        
        if add_to_disk:
            open(os.path.join(cachedir,filename),'w').write(contents) #disk cache

        #Memory cache
        tokens = filename.rpartition('/') #tokens[0]==folder, tokens[2]==UID
        if tokens[0] not in self.cache:
            self.cache[tokens[0]]=[]
        msg = email.parser.Parser().parsestr(contents)
        msgdict = CaseInsensitiveDict(msg.items())
        msgdict["UID"] = tokens[2]
        msgtime = 0
        if "Date" in msg:
            tztmt = email.utils.parsedate_tz(msg["Date"])
            if tztmt!=None:
                msgtime = email.utils.mktime_tz(tztmt)
        self.cache[tokens[0]].append((msgtime,msgdict))

        #Need to do special sorting for Tasks folder
        if tokens[0]!="Tasks":
            self.cache[tokens[0]].sort(key=lambda k: k[0],reverse=True) #inefficient
        else:
            def tasks_cmp(x,y):
                x_completed = 'X-MailTask-Completion-Status' in x[1] and x[1]['X-MailTask-Completion-Status']=="Completed"
                y_completed = 'X-MailTask-Completion-Status' in y[1] and y[1]['X-MailTask-Completion-Status']=="Completed"
                x_dinfo = 'X-MailTask-Date-Info' in x[1]
                y_dinfo = 'X-MailTask-Date-Info' in y[1]
                if x_completed and not y_completed:
                    return -1
                elif not x_completed and y_completed:
                    return 1
                elif x_dinfo and not y_dinfo:
                    return 1
                elif not x_dinfo and y_dinfo:
                    return -1
                elif x_dinfo: #and y_dinfo
                    xdate_ = email.utils.parsedate_tz(x[1]['X-MailTask-Date-Info'].split("/")[0].strip())
                    ydate_ = email.utils.parsedate_tz(y[1]['X-MailTask-Date-Info'].split("/")[0].strip())
                    xdate = email.utils.mktime_tz(xdate_) if xdate_!=None else 0
                    ydate = email.utils.mktime_tz(ydate_) if ydate_!=None else 0
                    return ydate-xdate
                else:
                    return x[0]-y[0]
            self.cache[tokens[0]].sort(cmp=tasks_cmp,reverse=True)

    ##remove_from_cache: remove a message or task from our local client cache, both in memory-and on-disk
    def remove_from_cache(self,filename):
        #Delete from memory cache
        tokens = filename.rpartition('/')
        flist = self.cache[tokens[0]]
        for i in range(len(flist)):
            if "UID" in flist[i][1] and flist[i][1]["UID"]==tokens[2]:
                del flist[i]
                break

        #Delete from disk
        os.remove(os.path.join(cachedir,filename))
    
    ##fatal_error_cancel_connection: abruptly sever connections to server
    def fatal_error_cancel_connection(self):
        self.smessage_conn.write(OnTask_Message("FECC-OFF","").get_message_string())
        self.cmessage_conn.write(OnTask_Message("FECC-OFF","").get_message_string())

    ##cid_info: initialize client connection by sending our CID
    def cid_info(self,cid):
        def f_1():
            try:
                self.cmessage_conn.write(OnTask_Message("CID-INFO",cid).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    ack = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if ack.cmd_id=="ACK":
                        return None
                    raise IOError("Unexpected reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##node_update: update single node on server
    def node_update(self,update_filename,update_str):
        def f_1():
            try:
                body = update_filename+"\n"+repr(int(time.time()))+"\n"+update_str
                self.cmessage_conn.write(OnTask_Message("NODE-UPDATE",body).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id=="ACK":
                        return None
                    elif reply.cmd_id=="NAK":
                        fl_alert("Warning: server preferred conflicting update.")
                        return None
                    else: #reply is probably "FECC-OFF"
                        raise IOError("Unexpected reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##send_email: instruct server to send an email
    def send_email(self,message):
        s_params = get_email_send_parameters_from_msg(message)
        accid = s_params[0]
        recipients = s_params[1]
        mt_utils.gen_message_id(message,s_params)
        message = mt_utils.unrfc822(message)
        message['User-Agent']=PROG_VERSION_STRING
        def f_1():
            try:
                body = accid+"\n"+",".join(recipients)+"\n"+message.as_string()
                self.cmessage_conn.write(OnTask_Message("SEND-EMAIL",body).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id!="ACK":
                        raise IOError("Unexpected reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)
        return message["Message-ID"]

    ##atomic_update: atomically update node on server
    # "mutator" parameter is callable that takes a single string and returns a string
    # It describes how the data received from the server should be atomically mutated
    def atomic_update(self,filename,mutator):
        def f_1(): #can't be called f_1: deadlock possible if it is
            global addrbook_update_time
            global addrbook_pong_received
            #Rate-limit addrbook updates so we don't screw things up
            if filename=="ADDRESSBOOK" and ( addrbook_update_time>=int(time.time()) or not addrbook_pong_received ):
                return f_1
            
            try:
                self.cmessage_conn.write(OnTask_Message("ATOMIC-UPDATE",filename).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                global addrbook_update_time
                global addrbook_pong_received
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id!="NODE-BODY-FULL":
                        raise IOError("Unexpected server reply")

                    updated_data = mutator(reply.body)
                    addrbook_update_time = int(time.time())
                    addrbook_pong_received=False
                    self.cmessage_conn.write(OnTask_Message("NODE-UPDATE",filename+"\n"+repr(addrbook_update_time)+"\n"+updated_data).get_message_string())
                    self.cmessage_conn.flush()
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id=="ACK":
                        return None
                    elif reply.cmd_id=="NAK":
                        fl_alert("Warning: server preferred conflicting update.")
                        addrbook_pong_received = True
                        return None
                    else: #reply is probably "FECC-OFF"
                        raise IOError("Unexpected reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##node_request: takes pathname of node requested
    def node_request(self,filename):
        def f_1():
            try:
                self.cmessage_conn.write(OnTask_Message("NODE-REQUEST",filename).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id!="NODE-BODY-FULL":
                        raise IOError("Unexpected server reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1

                #If we called this function, we must know we need the data from it in the cache somehow.
                self.add_to_cache(filename,reply.body)
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##folder_update_req: takes name of folder to search
    def folder_update_req(self,folder_name):
        def f_1():
            try:
                self.cmessage_conn.write(OnTask_Message("FOLDER-UPDATE-REQ",folder_name).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id!="FOLDER-UPDATE-NOTIFY":
                        raise IOError("Unexpected server reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1

                #Now, we need to search this folder in our cache, delete files where the UID no longer exists, and queue up NODE-REQUESTs for cases where the file does not exist in our cache.
                local_path = os.path.join(cachedir,folder_name)
                cached_file_set = set(os.listdir(local_path))
                current_server_set = set(reply.body.split("\n")) if reply.body!="" else set()

                #Delete old local files, deleted on server
                for stale_item in cached_file_set.difference(current_server_set) if folder_name!="Tasks" else cached_file_set:
                    self.remove_from_cache(folder_name+"/"+stale_item)

                #Add uncached new files, created on server
                for new_item in current_server_set.difference(cached_file_set) if folder_name!="Tasks" else current_server_set:
                    self.node_request(folder_name+"/"+new_item)
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##Keepalive packets
    def keepalive_notify(self):
        def f_1():
            try:
                self.cmessage_conn.write(OnTask_Message("KEEPALIVE-NOTIFY","").get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    ack = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if ack.cmd_id!="ACK":
                        raise IOError("Unexpected server reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)
    
    ##Does not return until connection is successful
    def connmanager(self):
        ui.block_w.show()
        Fl_flush()

        connected = False
        while not connected:
            try:
                #Connect to server, set up client sockets

                #Server socket
                self.smessage_conn = socket.socket()
                self.smessage_conn.connect((sys.argv[1],int(sys.argv[2])))
                self.smessage_conn_socket = self.smessage_conn
                self.smessage_conn = self.smessage_conn.makefile()

                #"HELLO" from server
                hello = OnTask_Message.message_from_socket(self.smessage_conn)
                if hello.cmd_id!="HELLO":
                    self.smessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.smessage_conn.close()
                    continue

                #Send password (yes, in the clear)
                self.smessage_conn.write(OnTask_Message("AUTHINFO",password).get_message_string())
                self.smessage_conn.flush()

                #"ACK" from server
                ack = OnTask_Message.message_from_socket(self.smessage_conn)
                if ack.cmd_id!="ACK":
                    self.smessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.smessage_conn.close()
                    continue

                #CID-REQUEST is next
                self.smessage_conn.write(OnTask_Message("CID-REQUEST","").get_message_string())
                self.smessage_conn.flush()

                #"CID-NOTIFY" from server
                cid_message = OnTask_Message.message_from_socket(self.smessage_conn)
                if cid_message.cmd_id!="CID-NOTIFY":
                    self.smessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.smessage_conn.close()
                    continue

                #Now we have our CID
                cid = cid_message.body

                #ACK to the server
                self.smessage_conn.write(OnTask_Message("ACK","").get_message_string())
                self.smessage_conn.flush()

                #Open connection to client socket
                self.cmessage_conn = socket.socket()
                self.cmessage_conn.connect((sys.argv[1],int(sys.argv[3])))
                self.cmessage_conn_socket = self.cmessage_conn
                self.cmessage_conn = self.cmessage_conn.makefile()

                #Send CID, so server knows who we are
                #This must be done using queue: server may block otherwise
                self.cid_info(cid)
                connected = True
            except:
                try:
                    self.smessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.smessage_conn.close()
                except:
                    pass
                try:
                    self.cmessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.cmessage_conn.close()
                except:
                    pass

        ui.block_w.hide()
        Fl_flush()

##Update cache and send info to server
# Returns True if any messages processed, False otherwise
# nsync.server_update_queue is a deque of pending client socket communiques
def server_synchronize():
    global cachedir
    
    #Have we processed any messages?
    messages_processed = False
    
    #select system call: I finally get to use this!
    retvals = select((nsync.smessage_conn_socket,nsync.cmessage_conn_socket),(nsync.cmessage_conn_socket,),(),0)

    #First: read from server notification socket if data is available
    #These are the possible server-initiated messages:
    #NODE-UPDATE-NOTIFY, CONNECT-STATUS-NOTIFY, FOLDER-INVALIDATE-NOTIFY,
    #KEEPALIVE-NOTIFY, and FECC-OFF.
    #We will ignore CONNECT-STATUS-NOTIFY.
    if nsync.smessage_conn_socket in retvals[0]:
        messages_processed = True
        smessage = OnTask_Message.message_from_socket(nsync.smessage_conn)
        if smessage.cmd_id=="NODE-UPDATE-NOTIFY":
            #Parse message body
            body = smessage.body
            uidpath = body[:body.index('\n')]
            modtime = int(body[(body.index('\n')+1):find_nth_substring('\n',2,body)])
            rfc822 = body[find_nth_substring('\n',2,body)+1:]

            cacheadd_necessary = True

            #Special case the address book
            if uidpath=="ADDRESSBOOK":
                os.remove(os.path.join(cachedir,uidpath))
                open(os.path.join(cachedir,uidpath),'w').write(rfc822)
                initialize_addrbook()
                cacheadd_necessary = False
            
            #Add body to cache if necessary
            tokens = uidpath.rpartition('/')
            if tokens[0] in nsync.cache:
                for record in nsync.cache[tokens[0]]:
                    if record[1]["UID"]==tokens[2] and record[0] >= modtime:
                        cacheadd_necessary = False
                        break

            if cacheadd_necessary:
                try: #if file already exists, we need to remove it from our memory and disk caches
                    os.stat(os.path.join(cachedir,uidpath))
                    nsync.remove_from_cache(uidpath)
                except OSError:
                    pass
                if rfc822!="": #only add to cache if file would not be empty
                    nsync.add_to_cache(uidpath,rfc822)

        elif smessage.cmd_id=="FOLDER-INVALIDATE-NOTIFY":
            #Delete all files in cached folder
            shutil.rmtree(os.path.join(cachedir,smessage.body)) #oh yeah this is secure yup
            os.mkdir(os.path.join(cachedir,smessage.body))
            
            #Clear entry in nsync.cache
            nsync.cache[smessage.body] = []
            
        elif smessage.cmd_id=="KEEPALIVE-NOTIFY":
            nsync.keepalive_notify()

        elif smessage.cmd_id=="FECC-OFF":
            #Disconnect/reconnect after notifying user of bug
            fl_alert("Server terminated connection and indicated protocol error:\n\n"+smessage.body+"\n\nClick OK to reconnect.")
            nsync.connmanager()

        #Send ACK message to server
        nsync.smessage_conn.write(OnTask_Message("ACK","").get_message_string())
        nsync.smessage_conn.flush()
        
    #Now, handle client-initiated messages through server_update_queue.
    if not len(nsync.server_update_queue):
        return messages_processed #No client-initiated messages if queue empty

    #Callables with f_1 in name only need cmessage_conn to be writeable.
    #f_2 (and others, theoretically) need cmessage_conn ready for reading.
    if repr(nsync.server_update_queue[0]).find("f_1")!=-1 and nsync.cmessage_conn_socket in retvals[1] or nsync.cmessage_conn_socket in retvals[0]:
        queued_cmessage_handler = nsync.server_update_queue.popleft()
        handler_retval = queued_cmessage_handler()
        nsync.cmessage_conn.flush()
        if handler_retval!=None:
            nsync.server_update_queue.appendleft(handler_retval)
        if handler_retval!=queued_cmessage_handler:
            messages_processed = True

    #Return whether we processed anything
    print "Update status:"
    print "addrbook_update_time: "+repr(addrbook_update_time)
    print "addrbook_pong_received: "+repr(addrbook_pong_received)
    print "len(nsync.server_update_queue): "+repr(len(nsync.server_update_queue))
    return messages_processed


def main():
    global cachedir
    global c_state
    global password
    global signature
    global nsync
    global ui

    #Name of program and intro text
    print "MailTask Alpha: The Email Manager"
    print "(c) 2015 by Patrick Simmons"
    print
    print "This program is free software: you can redistribute it and/or modify"
    print "it under the terms of the GNU General Public License as published by"
    print "the Free Software Foundation, either version 3 of the License, or"
    print "(at your option) any later version."

    print "This program is distributed in the hope that it will be useful,"
    print "but WITHOUT ANY WARRANTY; without even the implied warranty of"
    print "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"
    print "GNU General Public License for more details."
    print
    print "Libraries used:"
    print "html2text (c) 2012 Aaron Swartz (GPLv3)"
    print "requests_structures.py (c) The Requests Project (original Apachev2; any modifications GPLv3)"
    print
    print "This program is dedicated to the memory of Aaron Swartz."
    
    #Socket Default Timeout
    socket.setdefaulttimeout(600)

    #Set up ClientState: keeps track of UI view stack
    c_state = ClientState()
    c_state.stack.append((ClientState.FOLDER,"Tasks")) #This will always exist.
    
    #Set up UI
    ui = ClientUI()
    ui.make_window()

    #Read cache
    cachedir = os.path.join(os.path.expanduser("~"),".mailtask_data")

    #Initialize account information
    initialize_account_info()

    #Initialize addressbook
    try:
        initialize_addrbook()
    except IOError: #for when ADDRESSBOOK doesn't exist
        pass
    
    #Read in settings
    password = open(os.path.join(cachedir,"settings")).readline().rstrip()

    #Read in signature
    if os.path.isfile(os.path.join(cachedir,"signature")):
        signature = open(os.path.join(cachedir,"signature")).read().rstrip()
    else:
        signature = ""

    #Initial connection to server
    nsync = ClientNetSync()

    #Initialize nsync.cache with accounts and files from cache.

    #Local function to add all files in a folder to cache
    def folder_cache_add(folder):
        nsync.cache[folder]=[]
        for fname in os.listdir(os.path.join(cachedir,folder)):
            nsync.add_to_cache(folder+"/"+fname,open(os.path.join(cachedir,folder+"/"+fname)).read(),False)

    #If we have a pickle, use it; otherwise, read in all emails and parse them (slow)
    if os.path.isfile(cachedir+"/client.pickle"):
        nsync.cache = pickle.load(open(cachedir+"/client.pickle","rb"))
    else:
        #Add all account folders to cache
        for x in range(len(account_info)):
            folder_cache_add(repr(x)+"/INBOX")
            folder_cache_add(repr(x)+"/Sent")
        folder_cache_add("Tasks")

    #Run left_browser_callback with STACK_POPPED parameter to add initial values to left browser
    ui.left_browser_callback(ui.left_browser,ClientUI.STACK_PUSHED)
    
    #Initialize cache
    nsync.initialize_cache()

    #Sole thread runs GUI loop and updates cache from socket between wait() calls
    try:
        while ui.window.shown():
            Fl_wait(5)

            #server_synchronize run repeatedly as long as something processed.
            #left_browser_callback should also be run if server_synchronize
            #did anything, but only once in the event it is run multiple times.
            run_lb_callback = False
            try:
                while server_synchronize():
                    run_lb_callback = True
                if run_lb_callback:
                    ui.left_browser_callback(ui.left_browser)
                    run_lb_callback = False
            except IOError:
                nsync.connmanager()
    finally:
        #End of program.  Sign off.
        nsync.cmessage_conn.write(OnTask_Message("SIGN-OFF","").get_message_string())
        nsync.cmessage_conn.flush()

        #Backup our cache to a pickle
        pickle.dump(nsync.cache,open(cachedir+"/client.pickle",'wb'),pickle.HIGHEST_PROTOCOL)

if __name__=="__main__":
    main()
