#! /usr/bin/env python

# MailTask Alpha: The Email Manager
# Copyright (C) 2015  Patrick Simmons

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#Originally generated by flconvert

from collections import Counter,deque
from html2text import html2text
from request_structures import CaseInsensitiveDict,CaseInsensitiveDefaultDict

if __name__=="__main__":
    from fltk import *
    from FLTK_Advanced_Browser import *
else:
    def fl_alert(msg):
        print msg
    def Fl_flush():
        pass
    class empty:
        pass
    ui = empty()
    ui.block_w = empty()
    ui.block_w.show = ui.block_w.hide = Fl_flush
    
if __name__=="__main__":
    import mt_attache

import mt_utils
from ontask_messages import *

import base64
from copy import copy
import cPickle
import email
import email.message
import email.parser
import email.utils
import functools
from html2text import html2text
import os
import shutil
import socket
import sys
import time
from select import select

#This would be too annoying if it had a long name
gfind = mt_utils.find
CaseInsensitiveList = mt_utils.CaseInsensitiveList

##To use in user agent
PROG_VERSION_STRING="MailTask/20160503"

##Constant tuple containing all user-modifiable headers.
# Other headers are ignored.
MODIFIABLE_HEADERS = CaseInsensitiveList(["From","Reply-To","To","Cc","Bcc","Subject", "X-MailTask-Date-Info", "X-MailTask-Completion-Status", "Date"])

##Constant tuple containing headers likely to have an email address in them
EMAIL_MODIFIABLE_HEADERS = CaseInsensitiveList(["From","Reply-To","To","Cc","Bcc"])

##Constant tuple containing all headers that should not be auto-deleted when replyifying a message
NON_DELETE_HEADERS = CaseInsensitiveList(MODIFIABLE_HEADERS + CaseInsensitiveList(["References","MIME-Version","Content-Type"]))

##Account Info list
account_info = []

##Address book dictionary
address_book = {}

#These vars keep track of whether it's okay to update the address book
addrbook_update_time=0
addrbook_pong_received=True

##Initialize account info list
# Format of file: five lines per account
# 0. Username
# 1. Password
# 2. IMAP server
# 3. SMTP server
# 4. From Address String
# All we care about is from address string
def initialize_account_info():
    aifile = open(os.path.join(cachedir,"ACCOUNT_INFO"))
    lines = aifile.readlines()
    lines = map(str.rstrip,lines)
    for i in range(1,len(lines),5):
        account_info.append(lines[i+4])

##Initialize address book dictionary
def initialize_addrbook():
    global address_book
    global addrbook_pong_received
    
    address_book = {}
    addrbook_pong_received=True
    
    addrbookfile = open(os.path.join(cachedir,"ADDRESSBOOK"))
    lines = addrbookfile.readlines()
    lines = map(str.rstrip,lines)
    for i in range(0,len(lines),2):
        address_book[lines[i]] = set(lines[i+1].split(","))

##Get email address from an email header string
def get_email_addr_from_header(f_header):
    components = f_header.split()
    handled=False
    for token in components:
        if token.find('@')!=-1:
            return token.lstrip('<').rstrip('>').lower()
    return ""

##Get nickname from email header string
def get_nick_from_header(f_header):
    if get_email_addr_from_header(f_header)!=f_header and f_header.find("<") not in (0,-1):
        to_return = f_header[0:f_header.find("<")].strip().strip("'\"").strip()
        if to_return!="":
            return to_return
    return None

##Returns True if any address book entry has the set containing only the passed string as its value
def addrbook_rev_email_set_cardinality_one_lookup(a_val):
    for entry in address_book:
        if address_book[entry]==set([a_val]):
            return True
    return False

##Return email address or addresses for address book entry
def addrbook_lookup(key):
    if key not in address_book:
        email = get_email_addr_from_header(key)
        nick = get_nick_from_header(key)
        if nick!=None and (nick not in address_book or email not in address_book[nick]) and nick.find(',')==-1 and nick.find('\n')==-1 and not addrbook_rev_email_set_cardinality_one_lookup(email) and nick!=email:
            c_state.update_addr_book(nick,email)
        return key
    to_return=""
    for entry in address_book[key]:
        if to_return!="":
            to_return+=","
        to_return+=entry
    return to_return

##Return address book entry/entries for email address/addresses
def addrbook_reverse_lookup(ikey):
    to_return=""
    bag_of_addresses = set()
    for entry_ in mt_utils.decomma(ikey).split(","):
        entry = mt_utils.recomma(entry_)
        if entry in address_book:
            bag_of_addresses |= address_book[entry]
        else:
            email = get_email_addr_from_header(entry)
            bag_of_addresses.add(email)
            nick = get_nick_from_header(entry)
            if nick!=None and (nick not in address_book or email not in address_book[nick]) and nick.find(',')==-1 and nick.find('\n')==-1 and not addrbook_rev_email_set_cardinality_one_lookup(email) and nick!=email:
                c_state.update_addr_book(nick,email)
    while len(bag_of_addresses):
        largest_subset=set()
        lsubkey = None
        for key in address_book:
            if address_book[key] <= bag_of_addresses and len(address_book[key]) > len(largest_subset):
                largest_subset = copy(address_book[key])
                lsubkey=key
        if len(largest_subset):
            if to_return!="":
                to_return+=","
            to_return+=lsubkey
            bag_of_addresses-=largest_subset
        else:
            break
    for addr in bag_of_addresses:
        if to_return!="":
            to_return+=","
        partial_nick=None
        l_smallest_superset=sys.maxint
        for entry in address_book:
            if addr in address_book[entry] and len(address_book[entry]) < l_smallest_superset:
                partial_nick = entry
                l_smallest_superset = len(address_book[entry])
        if partial_nick:
            to_return+=partial_nick+" <"+addr+">"
        else:
            to_return+=addr
    return to_return
            

##Get string appropriate for use in main editor, given a
# dictionary of the headers in an email message
def get_editor_str(current_headers):
    current_headers.sort(key=lambda x: gfind(MODIFIABLE_HEADERS,x[0]) if gfind(MODIFIABLE_HEADERS,x[0])!=-1 else sys.maxint)
    newtext=""
    divide_reached=False
    for header in current_headers:
        if not divide_reached and header[0] not in MODIFIABLE_HEADERS:
            divide_reached=True
            newtext+="\n\n\n"
        newtext+=header[0]+": "+header[1].replace("\r\n","\n")+"\n"
    return newtext

##Given an email address header dictionary, return a
# pretty-printable string representing what to include
# in the From/To column of the message list.
# Despite the name of the parameter, the parameter may
# but need not be a default dictionary
def get_prettyprintable_column_str(dd_hdrs):
    #print "in get_prettyprintable_column_str"
    s_params = get_email_send_parameters_from_msg(dd_hdrs)

    #Are we the sender?
    if int(s_params[0])!=len(account_info): #yes
        #Then we print the destination addresses
        
        #Color dictionary
        color_dict = { 4 : FL_DARK_GREEN, 5 : FL_DARK_BLUE, 6 : FL_DARK_BLUE,
                       7 : FL_DARK_BLUE, 2 : 89, 3 : FL_DARK_MAGENTA, 1 : FL_DARK_RED }

        #Single octal number To/Cc/Bcc
        color_selector = (("To" in dd_hdrs) << 2) + (("Cc" in dd_hdrs) << 1) + ("Bcc" in dd_hdrs)

        #No recipients, no column value
        if not color_selector:
            return ""

        #Otherwise, return appropriate colored string
        best_header = dd_hdrs['To'] if 'To' in dd_hdrs else dd_hdrs['Cc'] if 'Cc' in dd_hdrs else dd_hdrs['Bcc']
        return "@C"+repr(color_dict[color_selector])+"@."+addrbook_reverse_lookup(best_header)
    elif 'From' in dd_hdrs: #not the sender
        return "@."+addrbook_reverse_lookup(dd_hdrs['From'])
    else:
        return "@.Unknown"

def get_email_send_parameters_from_msg(msg):
    #Make sure msg contains "From" key; abort if not
    if "From" not in msg:
        return (repr(len(account_info)),[])
    
    #Get sending account id
    i=0
    while i<len(account_info):
        if get_email_addr_from_header(msg["From"])==get_email_addr_from_header(account_info[i]):
            break
        i+=1
    accid=repr(i)

    #Create list of destination addrs
    dest_addrs = []
    for header in ("To","Cc","Bcc"):
        if header in msg:
            for address in mt_utils.decomma(msg[header]).split(","):
                dest_addrs.append(get_email_addr_from_header(address))

    return (accid, dest_addrs)

##Get rid of newlines etc. and make all email addresses separated by ","
def sanitize_msg_headers(msg):
    for header in ("From","To","Cc","Bcc","Reply-To"):
        if header in msg:
            msg.replace_header(header,msg[header].replace("\r"," ").replace("\n"," ").replace("\t"," "))

class ClientUI:
    #Enumeration of possible left_browser update causes
    SELF_INDUCED=0
    STACK_PUSHED=1
    STACK_POPPED=2
    UI_INDUCED=3

    #Menus for emails/tasks
    EMAIL_MENU = ("Headers","Body","Attachments","Related")
    TASK_MENU = ("Metadata","Description","Drafts","Files","Related")
    
    ##left_browser_callback:
    # - handle updating upper text display, lower text display, stack.
    # - Create choices for left browser, select first one if choices changed
    # - Update nsync.cache appropriately.
    # - Refresh main browser, but not through main_browser_callback.
    @staticmethod
    def left_browser_callback(widget,cause=SELF_INDUCED):
        FOLDER_VIEW=1
        EMAIL_VIEW=2
        TASK_VIEW=3
        ATTACHMENT_VIEW=4

        #UI-induced callbacks should often be ignored
        if cause==ClientUI.UI_INDUCED and (not ui.left_browser.value() or ui.left_browser.value()==ui.lb_selected):
            return 1
        elif cause==ClientUI.UI_INDUCED:
            cause=ClientUI.SELF_INDUCED

        #Can't process click if main editor is open.
        if ui.main_editor.visible():
            if ui.left_browser.value()!=ui.lb_selected:
                fl_alert("Illegal action: editor open.")
                ui.left_browser.select(ui.lb_selected)
            return 1

        #Back up mb_selected in case we mess with main_browser later (likely)
        ui.mb_selected = ui.main_browser.value()

        #Are we displaying info in the left pane about a task or a message?
        if len(c_state.stack) < 3:
            current_view = FOLDER_VIEW
        elif c_state.stack[-2][0]==ClientState.ATTACHMENTS:
            current_view = ATTACHMENT_VIEW
        elif c_state.stack[-2][0]==ClientState.MESSAGE and c_state.stack[-2][1].get_content_type()=="multipart/x.mailtask":
            current_view = TASK_VIEW
        else:
            current_view = EMAIL_VIEW

        #We were actually clicked or have been ordered to do a simple refresh.
        if cause==ClientUI.SELF_INDUCED:
            #Were we actually clicked?  If so, handle thlat.
            if ui.left_browser.value()!=ui.lb_selected:
                #Save new selection value
                ui.lb_selected = ui.left_browser.value()

                #We need to update the stack to reflect the new selection
                if ui.lb_selected!=0: #just ignore the click if it's a deselection
                    if current_view!=ATTACHMENT_VIEW:
                        c_state.stack.pop()

                    if current_view==FOLDER_VIEW:
                        c_state.stack.append((ClientState.FOLDER,ui.left_browser.text(ui.lb_selected)))
                        ui.main_browser.deselect() #necessary or get_stacktop_uidpath() won't work
                    elif current_view==EMAIL_VIEW:
                        select_id = ClientUI.EMAIL_MENU.index(ui.left_browser.text(ui.lb_selected))
                        if select_id==0:
                            c_state.stack.append((ClientState.HEADERS,))
                        elif select_id==1:
                            todisplay = mt_utils.get_body(c_state.stack[-1][1])
                            if todisplay:
                                c_state.stack.append((ClientState.SUBMESSAGE,todisplay))
                            else:
                                c_state.stack.append((ClientState.ATTACHMENTS,))
                        elif select_id==2:
                            c_state.stack.append((ClientState.ATTACHMENTS,))
                        else: #select_id==3
                            c_state.stack.append((ClientState.RELATED,))
                    elif current_view==TASK_VIEW:
                        select_id = ClientUI.TASK_MENU.index(ui.left_browser.text(ui.lb_selected))

                        if select_id==0:
                            c_state.stack.append((ClientState.HEADERS,))
                        elif select_id==1:
                            todisplay = mt_utils.get_body(c_state.stack[-1][1])
                            if todisplay:
                                c_state.stack.append((ClientState.SUBMESSAGE,todisplay))
                            else:
                                c_state.stack.append((ClientState.ATTACHMENTS,))
                        elif select_id==2:
                            c_state.stack.append((ClientState.DRAFTS,))
                        elif select_id==3:
                            c_state.stack.append((ClientState.ATTACHMENTS,))
                        else: #select_id==4
                            c_state.stack.append((ClientState.RELATED,))
                
                #Refreshing main browser/display handled below
                
        else: #pushed or popped: handle updating LB options set lb selection to 1
            ui.left_browser.clear()

            if current_view==FOLDER_VIEW:
                for i in range(len(account_info)):
                    ui.left_browser.add(repr(i)+"/INBOX")
                    ui.left_browser.add(repr(i)+"/Sent")
                ui.left_browser.add("Tasks")
            elif current_view==EMAIL_VIEW:
                for line in ClientUI.EMAIL_MENU:
                    ui.left_browser.add(line)
            elif current_view==TASK_VIEW:
                for line in ClientUI.TASK_MENU:
                    ui.left_browser.add(line)
            else: #ATTACHMENT_VIEW
                ui.left_browser.add("Attachment")
        
        #Okay, now we just refresh the main display/browser and upper and
        #lower main display/browser headers.

        #Upper text display
        ui.upper_text_display.label(c_state.stack[0][1] if c_state.get_stacktop_uidpath()==None else c_state.get_stacktop_uidpath())

        #Lower text display
        if current_view==FOLDER_VIEW:
            if c_state.stack[0][1]=="Tasks":
                ui.lower_text_display1.label("Title")
                ui.lower_text_display2.label("Type")
            else:
                ui.lower_text_display1.label("Subject")
                ui.lower_text_display1.label("From/To")
            ui.lower_text_display3.label("Date")
        elif c_state.stack[-1][0]==ClientState.ATTACHMENTS:
            ui.lower_text_display1.label("Filename")
            ui.lower_text_display2.label("Type")
            ui.lower_text_display3.label("Date")
        else:
            ui.lower_text_display1.label("")
            ui.lower_text_display2.label("")
            ui.lower_text_display3.label("")

        #Refresh main browser/display:
        if c_state.stack[-1][0]==ClientState.FOLDER: #Email folder or task folder
            ui.main_display.hide()
            ui.main_browser.show()

            ui.main_browser.clear()

            horizon = ui.mb_selected + 100
            mb_counter = 0
            if c_state.stack[-1][1]=="Tasks":
                for entry in nsync.cache[c_state.stack[-1][1]]:
                    if mb_counter>=horizon:
                        break
                    mb_counter+=1

                    if c_state.show_completed_tasks or entry[1]['X-MailTask-Completion-Status']!="Completed":
                        tasktype = mt_utils.get_task_type(entry[1])
                        if tasktype=="Checklist":
                            dinfo = mt_utils.browser_time(entry[1]['Date'])
                        elif tasktype=="Deadline":
                            dinfo = "D:"+mt_utils.browser_time(entry[1]['X-MailTask-Date-Info'],"%m/%d/%y %H:%M")
                        else: #Meeting
                            mtimes = map(str.strip,entry[1]['X-MailTask-Date-Info'].split("/"))
                            mtime_s1 = 0
                            mtime_s2 = 0
                            if email.utils.parsedate_tz(mtimes[0])!=None:
                                mtime_s1 = time.localtime(email.utils.mktime_tz(email.utils.parsedate_tz(mtimes[0])))
                            if email.utils.parsedate_tz(mtimes[1])!=None:
                                mtime_s2 = time.localtime(email.utils.mktime_tz(email.utils.parsedate_tz(mtimes[1])))
                            ctime = time.localtime()

                            current_year = ctime.tm_year==mtime_s1.tm_year
                            current_month = ctime.tm_mon==mtime_s1.tm_mon
                            current_day = ctime.tm_mday==mtime_s1.tm_mday

                            match_year = mtime_s1.tm_year==mtime_s2.tm_year
                            match_month = mtime_s1.tm_mon==mtime_s2.tm_mon
                            match_day = mtime_s1.tm_mday==mtime_s2.tm_mday
                            match_hour = mtime_s1.tm_hour==mtime_s2.tm_hour
                            match_minute = mtime_s1.tm_min==mtime_s2.tm_min

                            fmatstr1 = "%m/%d/%y %H:%M"
                            if current_year:
                                fmatstr1 = fmatstr1.replace("/%y","")
                            if current_year and current_month:
                                fmatstr1 = fmatstr1.replace("%m/","")
                            if current_year and current_month and current_day:
                                fmatstr1 = fmatstr1.replace("%d ","")

                            fmatstr2 = "%m/%d/%y %H:%M"
                            if match_year:
                                fmatstr2 = fmatstr2.replace("/%y","")
                            if match_year and match_month:
                                fmatstr2 = fmatstr2.replace("%m/","")
                            if match_year and match_month and match_day:
                                fmatstr2 = fmatstr2.replace("%d ","")
                            if match_hour and match_minute:
                                fmatstr2 = fmatstr2.replace("%H:%M","")
                            elif match_hour:
                                fmatstr2 = fmatstr2.replace("%H","")
                            elif match_minute:
                                fmatstr2 = fmatstr2.replace("%M","")
                            fmatstr2 = fmatstr2.rstrip()
                            
                            dinfo=time.strftime(fmatstr1,mtime_s1)+"-"+time.strftime(fmatstr2,mtime_s2)
                        ui.main_browser.add("@."+entry[1]['Subject']+"\t@."+tasktype+"\t@."+dinfo)
            else: #non-Task folder
                for entry in nsync.cache[c_state.stack[-1][1]]:
                    if mb_counter>=horizon:
                        break
                    mb_counter+=1

                    dd_hdrs = CaseInsensitiveDefaultDict(lambda: "", entry[1])
                    ui.main_browser.add("@."+dd_hdrs["Subject"]+"\t"+get_prettyprintable_column_str(entry[1])+"\t@."+(mt_utils.browser_time(dd_hdrs["Date"]) if dd_hdrs["Date"]!="" else ""))
            if ui.mb_selected<=len(nsync.cache[c_state.stack[-1][1]]):
                ui.main_browser.select(ui.mb_selected)
            else:
                ui.main_browser.deselect()
                ui.mb_selected=0
        elif c_state.stack[-1][0]==ClientState.HEADERS: #viewing headers/metadata
            ui.main_display.show()
            ui.main_browser.hide()

            #Refresh display
            ui.main_buffer.text(get_editor_str(CaseInsensitiveList(c_state.stack[-2][1].items())))
        elif c_state.stack[-1][0]==ClientState.ATTACHMENTS: #viewing attachments
            ui.main_display.hide()
            ui.main_browser.show()

            #Refresh attachments
            nsync.cache["ATTACHMENTS"] = []

            ##Processes single submsg containing an attachment
            def process_single_submsg(component):
                if 'Content-Disposition' in component and component['Content-Disposition'].split(";")[0].strip().lower()=="attachment":
                    adate=component.get_param("modification-date",0,"Content-Disposition")
                elif "Date" in component:
                    adate=component["Date"]
                else:
                    adate="Unknown"
                adict = {}
                adict[None]=component
                for header in component.items():
                    adict[header[0]]=header[1]
                nsync.cache["ATTACHMENTS"].append((adate,adict))
            
            ##Walks subtree of attachments, appends all to "ATTACHMENTS" key in cache
            mt_utils.walk_attachments(c_state.stack[-2][1],process_single_submsg,True)
            nsync.cache["ATTACHMENTS"].sort(key=lambda k: k[0],reverse=True)

            #Update browser
            ui.main_browser.clear()
            for x in nsync.cache["ATTACHMENTS"]:
                ui.main_browser.add("@."+x[1][None].get_param("filename","","Content-Disposition")+"\t@."+x[1][None].get_content_type()+"\t@."+mt_utils.browser_time(x[1][None].get_param("modification-date","","Content-Disposition")))
            if ui.mb_selected<=len(nsync.cache["ATTACHMENTS"]):
                ui.main_browser.select(ui.mb_selected)
            else:
                ui.main_browser.deselect()
                ui.mb_selected=0
        elif c_state.stack[-1][0]==ClientState.SUBMESSAGE: #viewing body of message or single attachment
            ui.main_browser.hide()
            ui.main_display.show()
            
            #Extensible attachment handler
            ui.main_buffer.text(mt_attache.display_submessage(c_state.stack[-1][1]).replace("\r\n","\n"))
        elif c_state.stack[-1][0]==ClientState.RELATED:
            ui.main_display.hide()
            ui.main_browser.show()

            #Related view.  We CANNOT TRUST nsync.cache["RELATED"] here!
            #That information MAY BE STALE.  It is OUR JOB to update it!
            #So, let's do that now.

            #Get all folders, remove "RELATED", "DRAFTS", "ATTACHMENTS"
            cachekeys = nsync.cache.keys()
            for key in ("RELATED","DRAFTS","ATTACHMENTS"):
                if key in cachekeys:
                    cachekeys.remove(key)

            oldrelated = nsync.cache["RELATED"] if "RELATED" in nsync.cache else []
            nsync.cache["RELATED"] = []
            primary_msg = c_state.stack[-2][1]
            if 'References' in primary_msg:
                for rmid in mt_utils.get_related_ids(primary_msg):
                    record = mt_utils.search_cache(rmid,oldrelated)
                    if record!=None:
                        nsync.cache["RELATED"].append(record)
                        continue
                    for key in cachekeys:
                        record = mt_utils.search_cache(rmid,nsync.cache[key])
                        if record!=None:
                            record[1]["FOLDER"]=key
                            nsync.cache["RELATED"].append(record)
                            break

            #Okay, now let's sort the RELATED list
            nsync.cache["RELATED"].sort(key=lambda k: k[0],reverse=True)

            #Update browser
            ui.main_browser.clear()
            for entry_ in nsync.cache["RELATED"]:
                entry = CaseInsensitiveDefaultDict(lambda: "", entry_[1])
                ui.main_browser.add("@."+entry["Subject"]+"\t@."+entry["From"]+"\t@."+entry["Date"])
            if ui.mb_selected<=len(nsync.cache["RELATED"]):
                ui.main_browser.select(ui.mb_selected)
            else:
                ui.main_browser.deselect()
                ui.mb_selected=0
        else: #c_state.stack[-1][0]==ClientState.DRAFTS
            ui.main_display.hide()
            ui.main_browser.show()

            #Drafts view.  We CANNOT TRUST nsync.cache["DRAFTS"] here!
            #That information MAY BE STALE.  It is OUR JOB to update it!
            #So, let's do that now.
            nsync.cache["DRAFTS"]=[]
            primary_msg = c_state.stack[-2][1]

            for submsg in primary_msg.get_payload():
                epochtime = email.utils.mktime_tz(email.utils.parsedate_tz(submsg["Date"])) if submsg["Date"] and email.utils.parsedate_tz(submsg["Date"])!=None else 0
                if submsg.get_content_type()=="message/rfc822":
                    nsync.cache["DRAFTS"].append((epochtime,{ None: submsg }))

            #Sort DRAFTS list in cache
            nsync.cache["DRAFTS"].sort(key=lambda k: k[0],reverse=True)

            #Okay, done with that.  Update browser.
            ui.main_browser.clear()
            for entry_ in nsync.cache["DRAFTS"]:
                entry = entry_[1][None]
                ui.main_browser.add("@."+entry.get("Subject","")+"\t"+get_prettyprintable_column_str(entry)+"\t@."+entry.get("Date",""))
            if ui.mb_selected<=len(nsync.cache["DRAFTS"]):
                ui.main_browser.select(ui.mb_selected)
            else:
                ui.main_browser.deselect()
                ui.mb_selected=0

        print c_state.stack
        return 1

    ##main_browser_callback: called when main_browser enter pressed
    # add appropriate entries to stack, then call left_browser_callback
    @staticmethod
    def main_browser_callback():
        ui.mb_selected=ui.main_browser.value()

        if not ui.mb_selected:
            return 1
        
        if c_state.stack[-1][0]==ClientState.ATTACHMENTS: #attachments
            attachment = nsync.cache["ATTACHMENTS"][ui.mb_selected-1][1][None]
            c_state.stack.append((ClientState.SUBMESSAGE,attachment))
            if not isinstance(attachment.get_payload(),str):
                c_state.stack.append((ClientState.HEADERS,))            
        elif c_state.stack[-1][0]==ClientState.FOLDER: #folder
            uidpath = c_state.stack[0][1]+"/"+nsync.cache[c_state.stack[0][1]][ui.mb_selected-1][1]["UID"]
            c_state.stack.append((ClientState.MESSAGE,email.parser.Parser().parse(open(os.path.join(cachedir,uidpath))),uidpath))
            c_state.stack.append((ClientState.HEADERS,))
        elif c_state.stack[-1][0]==ClientState.RELATED: #RELATED view
            uidpath = nsync.cache["RELATED"][ui.mb_selected-1][1]["FOLDER"]+"/"+nsync.cache["RELATED"][ui.mb_selected-1][1]["UID"]
            c_state.stack.append((ClientState.MESSAGE,email.parser.Parser().parse(open(os.path.join(cachedir,uidpath))),uidpath))
            c_state.stack.append((ClientState.HEADERS,))
        elif c_state.stack[-1][0]==ClientState.DRAFTS: #DRAFTS view
            c_state.stack.append((ClientState.SUBMESSAGE,nsync.cache["DRAFTS"][ui.mb_selected-1][1][None]))
            c_state.stack.append((ClientState.HEADERS,))

        ui.left_browser_callback(ui.left_browser,ClientUI.STACK_PUSHED)
        return 1

    ##Turns cut object in browser gray
    def show_cut_highlighted(self):
        pass

    def make_window(self):

        #Create main window
        self.window = Fl_Double_Window(516, 221, 920, 675, "MailTask Alpha")
        self.window.resizable(self.window)

        self.left_browser = Fl_Select_Browser(0, 0, 165, 675)
        self.left_browser.type(2) #undocumented (wtf); makes selection highlight stick
        self.left_browser.when(FL_WHEN_CHANGED)
        self.left_browser.callback(lambda x: ClientUI.left_browser_callback(x,ClientUI.UI_INDUCED))
        self.left_browser.end()

        #Store the currently selected line in the left browser
        self.lb_selected = 1

        #Store the currently selected line in the main browser
        self.mb_selected = 0

        self.upper_text_display = Fl_Box(165, 0, 755, 40)
        self.upper_text_display.align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE)

        self.lower_text_display1 = Fl_Box(165, 40, 350, 40)
        self.lower_text_display1.box(FL_NO_BOX)
        self.lower_text_display1.align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE)

        self.lower_text_display2 = Fl_Box(515, 40, 250, 40)
        self.lower_text_display2.box(FL_NO_BOX)
        self.lower_text_display2.align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE)

        self.lower_text_display3 = Fl_Box(765, 40, 155, 40)
        self.lower_text_display3.box(FL_NO_BOX)
        self.lower_text_display3.align(FL_ALIGN_LEFT|FL_ALIGN_INSIDE)

        self.main_editor = Fl_Text_Editor(165, 80, 755, 595)
        self.main_buffer = Fl_Text_Buffer()
        self.main_editor.buffer(self.main_buffer)
        self.main_editor.wrap_mode(3,0)
        self.main_editor.hide()
        self.main_editor.end()
        self.main_display = Fl_Text_Display(165,80,755,595)
        self.main_display.buffer(self.main_buffer)
        self.main_display.wrap_mode(3,0)
        self.main_editor.hide()

        #Whether main_editor or main_browser is visible depends on current mode

        #Custom browser class, so we can override keyboard handler
        #FLTK's documentation says a callback with FL_WHEN_ENTER_KEY_ALWAYS
        #should do the equivalent of this, but it doesn't, so we need to do
        #this instead.  FLTK's abysmal documentation strikes again.
        FLTK_Advanced_Parent = FLTK_Advanced_Browser(Fl_Select_Browser)
        class Custom_Main_Browser(FLTK_Advanced_Parent):
            def handle(self,etype):
                #Is this the correct event to be handling this?  If not, return 0
                if etype!=FL_KEYDOWN or Fl_event_key()!=FL_Enter or Fl_event_state(FL_CTRL):
                    return FLTK_Advanced_Parent.handle(self,etype)
                return ClientUI.main_browser_callback()

        self.main_browser = Custom_Main_Browser(165,80,755,595)
        self.main_browser.type(2) #stupid undocumented crap (see above)
        self.main_browser.column_widths((350,250,155))
        self.main_browser.hide()
        
        self.window.end()
        self.window.show()

        #Global shortcut handler
        Fl_add_handler(ClientState.shortcut_handler)
        
        #Blocking dialog box
        self.block_w = Fl_Single_Window(500,50)
        self.block_w.label("Please wait")
        self.block_w.set_modal()
        self.block_w.callback(lambda x: 1)
        self.boxblock = Fl_Box(0,0,500,50,"Server synchronization in progress.")
        self.boxblock.align(FL_ALIGN_INSIDE|FL_ALIGN_CENTER)
        self.block_w.end()


class ClientState:
    #Enumeration of possible stack type tags
    FOLDER=0
    MESSAGE=1
    HEADERS=2
    ATTACHMENTS=3
    SUBMESSAGE=4
    RELATED=5
    DRAFTS=6
    
    ##Class to use as type for clipboard
    # Type of value is true string when is_uidpath is false
    class Clipboard:
        UIDPATH=0
        TRUESTRING=1
        SUBMESSAGE=2
        
        def __init__(self,typ,val):
            self.type = typ
            self.value = val

    ##Initialize ClientState object
    def __init__(self):
        #Current view stack
        self.stack = []

        #Rate limit address book updates
        self.addrbook_rate_limit = 0

        #Do we show completed tasks in task view
        self.show_completed_tasks = False

        #Internal clipboard objects
        self.clipboard = ClientState.Clipboard(ClientState.Clipboard.TRUESTRING,"") #Contents of clipboard stored as MIME-encoded string
        self.deathslayer = lambda: None #callable that removes cut item; called upon paste
        #self.last_action_paste_from_copy = False #why is this here?

    ##Internal utility method to get single component of bottom-most message on the stack
    def get_stacktop_internal(self,component):
        for i in range(-1,-len(self.stack)-1,-1):
            if self.stack[i][0]==ClientState.MESSAGE:
                return self.stack[i][component]
        return None

    ##Utility method to handle get Message object of current top of stack
    # Specifically, the returned Message object should contain the entire
    # message that needs to be uploaded to the path from
    # get_stacktop_uidpath below.
    def get_stacktop_msg(self):
        return self.get_stacktop_internal(1)

    ##Utility method to handle getting UIDpath of current top of stack
    def get_stacktop_uidpath(self):
        return self.get_stacktop_internal(2)

    #Methods to handle shortcuts

    ##Handle editor state toggle
    def toggle_editor(self):
        if ui.main_editor.visible():
            ui.main_editor.hide()
            ui.main_display.show()
            if self.stack[-1][0]==ClientState.HEADERS:
                #Remove blank lines so parser won't screw up.
                headerlines = ui.main_buffer.text().splitlines()
                headerlines[:] = (line for line in headerlines if line.strip()!="")
            
                #Parse user's input
                n_message = email.parser.HeaderParser().parsestr("\n".join(headerlines))
                for header in MODIFIABLE_HEADERS:
                    if n_message[header]!=None:
                        if header in EMAIL_MODIFIABLE_HEADERS:
                            replacement_header=""
                            for entry in n_message[header].split(","):
                                if replacement_header!="":
                                    replacement_header+=","
                                replacement_header+=addrbook_lookup(entry)
                            if header in self.stack[-2][1]:
                                self.stack[-2][1].replace_header(header,replacement_header)
                            else:
                                self.stack[-2][1][header]=replacement_header
                        else:
                            del self.stack[-2][1][header]
                            self.stack[-2][1][header]=n_message[header]
                    else: #delete missing header
                        del self.stack[-2][1][header]
            else:
                self.stack[-1][1].set_payload(ui.main_buffer.text())

            #Send updated file to server
            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
        else:
            if self.stack[-1][0]==ClientState.FOLDER and self.stack[0][1].find("Tasks")!=0 or self.stack[-1][0]!=ClientState.FOLDER and self.get_stacktop_uidpath().find("Tasks")!=0:
                response = fl_ask("Warning: You are about to modify an IMAP message.  Are you sure you want to do this?")
                if not response:
                    return 1
            
            self.oldtext = ui.main_buffer.text()
            ui.main_display.hide()

            if self.stack[-1][0]==ClientState.HEADERS:
                #Buffer's text must use address book keys for modifiable headers
                header_dict = CaseInsensitiveDict(self.stack[-2][1].items())
                for header in MODIFIABLE_HEADERS:
                    if header in EMAIL_MODIFIABLE_HEADERS and header in header_dict:
                        header_dict[header] = addrbook_reverse_lookup(header_dict[header])

                #Now, we need to recreate the message's tuple list
                current_headers=CaseInsensitiveList()
                for header in header_dict:
                    current_headers.append((header,header_dict[header]))
                ui.main_buffer.text(get_editor_str(current_headers))
                ui.main_editor.show()
            else:
                ui.main_editor.show()
        return 1
            
    # def cancel_editor(self):
    #     if not ui.main_editor.visible():
    #         return 0

    #     ui.main_buffer.text(self.oldtext)
    #     ui.main_editor.hide()
    #     ui.main_display.show()
    #     return 1

    def cut_obj(self):
        if Fl_Widget.visible(ui.main_browser) and not ui.main_browser.value():
            return 0

        if ui.main_editor.visible():
            return 0

        #If we're not ultimately cutting a task, or from a task, error out
        if self.get_stacktop_uidpath()==None or self.get_stacktop_uidpath().find("Tasks")!=0:
            fl_alert("Can't cut from non-Task object.")
            return 1

        c_index = ui.main_browser.value() #1-based!
        if not ui.main_browser.value():
            fl_alert("Nothing selected.")
            return 1

        if self.stack[-1][0]==ClientState.DRAFTS:
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,nsync.cache["DRAFTS"][c_index-1][1][None])
            slayeruidpath = self.get_stacktop_uidpath()
            stacktopmsg = self.get_stacktop_msg()
            child = nsync.cache["DRAFTS"][c_index-1][1][None]
            def delcomponent():
                mt_utils.delete_payload_component(stacktopmsg,child)
                nsync.node_update(slayeruidpath,stacktopmsg.as_string())
            self.deathslayer = delcomponent            
        elif self.stack[-1][0]==ClientState.RELATED:
            selected_message_headers = nsync.cache["RELATED"][c_index-1][1]
            related_msg_uidpath = selected_message_headers["FOLDER"]+"/"+selected_message_headers["UID"]
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.UIDPATH,related_msg_uidpath)

            slayer_uidpath = self.get_stacktop_uidpath()
            slayer_origmsg = self.get_stacktop_msg()
            slayer_cutrelatedmid = mt_utils.get_message_id(selected_message_headers,selected_message_headers["FOLDER"])
            def slay_from_references():
                newreferencelist = mt_utils.get_related_ids(slayer_origmsg)
                index = gfind(newreferencelist,slayer_cutrelatedmid)
                if index==-1:
                    fl_alert("Warning: failed to delete cut message ID from related list of original message.")
                else:
                    del newreferencelist[index]
                    mt_utils.set_related_ids(slayer_origmsg,newreferencelist)
                    nsync.node_update(slayer_uidpath,slayer_origmsg.as_string())
            self.deathslayer = slay_from_references
        elif self.stack[-1][0]==ClientState.HEADERS:
            fl_alert("Email headers cannot be cut, only copied.")
        elif self.stack[-1][0]==ClientState.FOLDER: #folder view
            fl_alert("Can't cut tasks, only copy them.")
        elif self.stack[-1][0]==ClientState.ATTACHMENTS: #We are viewing attachments
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,nsync.cache["ATTACHMENTS"][c_index-1][1][None])

            def slay_from_attachments():
                mt_utils.delete_payload_component(self.stack[-2][1],nsync.cache["ATTACHMENTS"][c_index-1][1][None])
            self.deathslayer = slay_from_attachments
        else: #We are viewing a non-header component of a message
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,self.stack[-1][1])

            slayeruidpath = self.get_stacktop_uid()
            stacktopmsg = self.get_stacktop_msg()

            #Finding our direct parent is a little tricky.
            for i in range(-2,-len(self.stack)-1,-1):
                if self.stack[i][0]==ClientState.SUBMESSAGE or self.stack[i][0]==ClientState.MESSAGE:
                    parent = self.stack[i][1]
                    break
            
            child = self.stack[-1][1]
            def delcomponent():
                mt_utils.delete_payload_component(parent,child)
                nsync.node_update(slayeruidpath,stacktopmsg.as_string())
            self.deathslayer = delcomponent
        return 1

    def copy_obj(self):
        if Fl_Widget.visible(ui.main_browser) and not ui.main_browser.value():
            return 0

        if ui.main_editor.visible():
            return 0

        c_index = ui.main_browser.value() #1-based!
        self.deathslayer = lambda: None

        if self.stack[-1][0]==ClientState.RELATED: #RELATED view
            selected_message_headers = nsync.cache["RELATED"][c_index-1][1]
            related_msg_uidpath = selected_message_headers["FOLDER"]+"/"+selected_message_headers["UID"]
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.UIDPATH,related_msg_uidpath)
        elif self.stack[-1][0]==ClientState.DRAFTS: #DRAFTS view
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,nsync.cache["DRAFTS"][c_index-1][1][None])
        elif self.stack[-1][0]==ClientState.HEADERS:
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.TRUESTRING,ui.main_buffer.text())
        elif self.stack[-1][0]==ClientState.ATTACHMENTS: #We are viewing attachments
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,nsync.cache["ATTACHMENTS"][c_index-1][1][None])
        elif self.stack[-1][0]==ClientState.FOLDER: #folder view
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.UIDPATH,self.stack[0][1]+"/"+nsync.cache[self.stack[0][1]][c_index-1][1]["UID"])
        else: #Viewing non-header component of message
            self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,self.stack[-1][1])
        return 1

    def paste_obj(self):
        #If the editor is visible, the type of the clipboard object must be TRUESTRING
        if ui.main_editor.visible() and self.clipboard.type!=ClientState.Clipboard.TRUESTRING:
            fl_alert("Clipboard does not contain a string.")
            return 1
        elif not ui.main_editor.visible() and self.clipboard.type==ClientState.Clipboard.TRUESTRING:
            fl_alert("Clipboard contains a string, but the editor is not open.")
            return 1
        elif self.clipboard.type==ClientState.Clipboard.TRUESTRING:
            ui.main_editor.insert(self.clipboard.value)
        elif self.clipboard.type==ClientState.Clipboard.UIDPATH:
            if self.stack[-1][0]==ClientState.FOLDER: #folder view
                nsync.node_update(self.stack[-1][1]+"/NEWMESSAGE",open(os.path.join(cachedir,self.clipboard.value)).read())
            elif self.stack[-1][0]==ClientState.HEADERS: #This doesn't make sense
                return 0
            else: #RELATED message view, or single message view, or ATTACHMENTS view.  All do the same thing: encapsulate and attach the message whose UID is on the clipboard.
                msg = email.parser.Parser().parse(open(os.path.join(cachedir,self.clipboard.value)))

                if 'Message-ID' in msg:
                    rel_ids = mt_utils.get_related_ids(self.stack[-2][1])
                    rel_ids.append(mt_utils.get_message_id(msg,None))
                    mt_utils.set_related_ids(self.stack[-2][1],rel_ids)
                if self.stack[-1][0]!=ClientState.RELATED: #DRAFTS or single message view
                    mt_utils.attach_payload(self.stack[-2][1],msg)

                #Update modified message
                nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
                
            #refresh screen to show new message in related
            ui.left_browser_callback(ui.left_browser)
        else: #clipboard is SUBMESSAGE
            if self.stack[-1][0]==ClientState.RELATED: #RELATED message view
                fl_alert("Cannot paste submessage to related message view.")
                return 1
            elif self.stack[-1][0]==ClientState.DRAFTS: #DRAFTS message view
                self.stack[-2][1].attach(self.clipboard.value)
            elif self.stack[-1][0]==ClientState.ATTACHMENTS:
                mt_utils.attach_payload(self.stack[-2][1],self.clipboard.value)
            elif self.stack[-1][0]==ClientState.FOLDER: #folder view
                fl_alert("Cannot paste submessage to folder.")
                return 1
            else: #single message view (viewing headers or non-headers, no matter)
                mt_utils.attach_payload(self.stack[-2][1],self.clipboard.value)

            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())

        self.deathslayer()
        self.deathslayer = lambda: None
        return 1

    ##delete_obj: delete currently highlighted object from parent message,
    #             or currently highlighted message from parent folder
    def delete_obj(self):
        if ui.main_editor.visible() or Fl_Widget.visible(ui.main_browser) and not ui.main_browser.value():
            return 0

        if self.stack[-1][0]==ClientState.FOLDER and self.stack[0][1].find("Tasks")!=0 or self.stack[-1][0]!=ClientState.FOLDER and self.get_stacktop_uidpath().find("Tasks")!=0:
            response = fl_ask("Warning: You are about to modify an IMAP folder.  Are you sure you want to do this?")
            if not response:
                return 1
        
        b_index = ui.main_browser.value()
        
        if self.stack[-1][0]==ClientState.RELATED: #RELATED message view
            s_headers = nsync.cache["RELATED"][b_index-1][1]
            relmID_to_delete = s_headers["Message-ID"].strip()
            newreferencelist = mt_utils.get_related_ids(self.stack[-2][1])
            index = gfind(newreferencelist,relmID_to_delete)
            if index==-1:
                fl_alert("Warning: failed to delete cut message ID from related list of original message.")
            else:
                del newreferencelist[index]
                mt_utils.set_related_ids(self.stack[-2][1],newreferencelist)
                nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
            ui.left_browser_callback(ui.left_browser)
        elif self.stack[-1][0]==ClientState.DRAFTS: #"DRAFTS"
            draft_to_delete = nsync.cache["DRAFTS"][b_index-1][1][None]
            payload = self.stack[-2][1].get_payload()
            del payload[payload.index(draft_to_delete)]
            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
        elif self.stack[-1][0]==ClientState.HEADERS:
            fl_alert("Cannot delete email headers.")
        elif self.stack[-1][0]==ClientState.ATTACHMENTS:
            mt_utils.delete_payload_component(self.stack[-2][1],nsync.cache["ATTACHMENTS"][b_index-1][1][None])
            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
        elif self.stack[-1][0]==ClientState.FOLDER: #folder view
            nsync.node_update(self.stack[0][1]+"/"+nsync.cache[self.stack[0][1]][b_index-1][1]["UID"],"")
        else: #viewing non-header component of message
            payload = self.stack[-2][1].get_payload()
            if not isinstance(payload,list):
                fl_alert("Cannot delete sole component of message body")
            mt_utils.delete_payload_component(self.stack[-2][1],self.stack[-1][1])

            #This is complicated by the fact that we may be viewing a draft message
            nsync.node_update(self.get_stacktop_uidpath(),self.get_stacktop_msg().as_string())
            ui.left_browser_callback(ui.left_browser)
        return 1

    def pop_view(self):
        if ui.main_editor.visible():
            response = fl_ask("The editor is open.  Are you sure you want to cancel any unsaved edits?")
            
            if not response:
                return 1

            ui.main_editor.hide()
            ui.main_buffer.text(self.oldtext)
            ui.main_display.show()
            ui.left_browser_callback(ui.left_browser)
            return 1

        #Can't pop if already at top of stack
        if len(self.stack)==1:
            return 1

        #Still here, no editor open and not at top of stack
        self.stack.pop()
        if self.stack[-1][0]!=ClientState.ATTACHMENTS: #We were NOT viewing an attachments, so pop again.
            self.stack.pop()
        ui.left_browser_callback(ui.left_browser,ClientUI.STACK_POPPED)
        return 1

    ##Must be viewing a draft message
    # After sending message, delete draft message from parent task, add its Message-ID
    # to parent task, and, if there are no remaining draft messages in task, mark the
    # task completed.
    # Service client will unmark completed task when new message comes in referencing
    # any emails associated with task.
    def send_email(self):
        if ui.main_editor.visible():
            fl_alert("Must close editor before sending mail.")
            return 1
        
        inside_draft = False
        if self.stack[-1][0]==ClientState.DRAFTS: #In DRAFTS view
            b_index = ui.main_browser.value()
            if not b_index:
                fl_alert("No message selected.")
                return 1

            draft_to_send = nsync.cache["DRAFTS"][b_index-1][1][None]
            parent_of_draft = self.stack[-2][1]
            parent_uid = self.stack[-2][2]
        elif len(self.stack)>3 and self.stack[-3][0]==ClientState.DRAFTS:
            inside_draft = True
            draft_to_send = self.stack[-2][1]
            parent_of_draft = self.stack[-4][1]
            parent_uid = self.stack[-4][2]
        else:
            fl_alert("Not viewing a draft message.")
            return 1

        #Do we have any recipients?
        s_params = get_email_send_parameters_from_msg(draft_to_send)
        if int(s_params[0])==len(account_info) or not len(s_params[1]):
            fl_alert("Incomplete or invalid message headers.")
            return 1

        #Still here, we've got draft_to_send, parent_of_draft, and parent_uid
        #Set date to current time
        if "Date" in draft_to_send:
            draft_to_send.replace_header("Date",email.utils.formatdate(localtime=True))
        else:
            draft_to_send["Date"]=email.utils.formatdate(localtime=True)
        
        #Send actual message
        sent_mid = nsync.send_email(draft_to_send)

        #Delete draft email from parent task
        parent_payload = parent_of_draft.get_payload()
        todelete_idx = gfind(parent_payload,draft_to_send)
        if todelete_idx==-1:
            fl_alert("System error: draft not found in parent.")
            return 1
        del parent_payload[todelete_idx]

        #Add sent MID to related messages of parent task
        if parent_uid!="Tasks/BLACKHOLE":
            relmids = mt_utils.get_related_ids(parent_of_draft)
            relmids.append(sent_mid)
            mt_utils.set_related_ids(parent_of_draft,relmids)
        
        #Update parent task
        nsync.node_update(parent_uid,parent_of_draft.as_string())

        #If we're inside the message we're sending, pop our stack.
        if inside_draft:
            self.stack.pop() #Interior component of sent message
            self.stack.pop() #Message itself

            #We're done now; we're viewing the DRAFTS section of the task
            #we just sent.  Unless the task is BLACKHOLE.  Then pop the
            #task off the stack as well.
            if self.stack[-2][2]=="Tasks/BLACKHOLE":
                self.stack.pop()
                self.stack.pop()

        #Refresh screen
        ui.left_browser_callback(ui.left_browser,ClientUI.STACK_POPPED if inside_draft else ClientUI.SELF_INDUCED)

    ##Send every draft email associated with task
    # Must have task selected or be viewing task
    def send_task(self):
        if self.stack[0][1]!="Tasks":
            fl_alert("Not viewing tasks.")
            return 1

        if len(self.stack) > 3:
            fl_alert("There's a task on the stack, but you're somewhere else.")
            return 1

        tval = ui.main_browser.value()
        if not tval:
            fl_alert("No task highlighted.")
            return 1
        taskuid = "Tasks/"+nsync.cache["Tasks"][tval-1][1]["UID"]

        if len(self.stack)==1:
            taskmsg = email.parser.Parser().parse(open(os.path.join(cachedir,taskuid)))
        else:
            taskmsg = self.stack[1][1] #NOT [-1][1]: this isn't a bug (well, I don't think it is)

        payload = taskmsg.get_payload()
        
        i=0
        while i<len(payload):
            draft_to_send = payload[i]
            if not draft_to_send["Content-Type"]=="message/rfc822":
                i+=1
                continue

            #Set date to current time
            if "Date" in draft_to_send:
                draft_to_send.replace_header("Date",email.utils.formatdate(localtime=True))
            else:
                draft_to_send["Date"]=email.utils.formatdate(localtime=True)

            sent_mid = nsync.send_email(draft_to_send)
            del payload[i]
            taskmsg.set_payload(payload)

            #Add sent MID to related messages of parent task
            relmids = mt_utils.get_related_ids(taskmsg)
            relmids.append(sent_mid)
            mt_utils.set_related_ids(taskmsg,relmids)

            nsync.node_update(taskuid,taskmsg.as_string())

        #Refresh screen
        ui.left_browser_callback(ui.left_browser)
        
        return 1

    ##Turn a message into a "reply all"
    def make_reply_all(self):
        hdictstr='{ "To" : to_set, "Cc" : cc_set, "Bcc" : bcc_set }'
        return self.make_reply_internal(hdictstr)
    
    ##Turn a message into a "reply to sender"
    def make_reply_sender(self):
        hdictstr='{ "To" : unused_set, "Cc" : unused_set, "Bcc" : unused_set }'
        return self.make_reply_internal(hdictstr)
    
    ##Turn a message into a reply.
    # Must be viewing headers of draft message for this to work
    def make_reply_internal(self,header_dictstr):
        if len(self.stack) < 5 or self.stack[-1][0]!=ClientState.HEADERS or self.stack[-3][0]!=ClientState.DRAFTS:
            fl_alert("Refusing to replyify non-draft message.")
            return 1

        #Just an alias, for clarification
        msg=self.stack[-2][1]

        #Sanitize headers (no newlines and tabs; comma separators only)
        sanitize_msg_headers(msg)
        
        #Backup Message-ID if exists
        if 'Message-ID' in msg:
            backup_mid = msg['Message-ID']
        else:
            backup_mid = ""
        
        #Delete extraneous headers
        for header_ in msg.items():
            header = header_[0]
            if header not in NON_DELETE_HEADERS:
                del msg[header]

        #Okay, now replyify the message.
        #Replyification sets
        to_set = set()
        cc_set = set()
        bcc_set = set()
        unused_set = set()
        
        #Replyification dicts
        header_dict=eval(header_dictstr)
        recon_dict={ "To" : to_set, "Cc" : cc_set, "Bcc" : bcc_set }
        
        #Replyified from header
        if "From" in msg:
            oldfrom = msg["From"]
        elif "Reply-To" in msg:
            oldfrom = msg["Reply-To"]
        else:
            oldfrom = "a dark and mysterious stranger"

        def add_if_not_already_in_set(set,addr):
            for item in to_set:
                if get_email_addr_from_header(item)==get_email_addr_from_header(email):
                    return
            set.add(get_email_addr_from_header(addr))

        from_addr=""
        for header in ("From","To","Cc","Bcc","Reply-To"):
            if header not in msg:
                continue

            if header in ("From","Reply-To"):
                for email in mt_utils.decomma(msg[header]).split(","):
                    add_if_not_already_in_set(to_set,email)
            else:
                for email in mt_utils.decomma(msg[header]).split(","):

                    #Check if this address is in account_info
                    address_is_us=False
                    for acct_from in account_info:
                        if get_email_addr_from_header(acct_from)==get_email_addr_from_header(email):
                            address_is_us=True
                            
                            #Set our from address, if we don't have one.
                            if from_addr=="":
                                from_addr=email

                    if not address_is_us:
                       add_if_not_already_in_set(header_dict[header],email)

        #If we can't tell what account to use for from address, use account 0.
        if from_addr=="":
            from_addr=account_info[0]
        #Now, reconstruct headers
        del msg["From"]
        msg["From"]=from_addr

        #Replyify To,Cc,Bcc
        for header in ("To","Cc","Bcc"):
            del msg[header]
            if len(recon_dict[header]):
                msg[header] = ",".join(recon_dict[header])

        #Now replyify the References header
        if 'References' in msg:
            idlist = mt_utils.get_related_ids(msg)
            idlist.append(backup_mid)
            mt_utils.set_related_ids(msg,idlist)
        else:
            msg['References']=backup_mid

        #Good.  Now, replyify body.
        body = mt_utils.get_body(msg)

        #VILE CREATURE, THOU DURST CALL UPON ME?
        #WALK NO MORE, PERVERSION OF NATURE!
        if body.get_content_type()=="text/html":
            payload = mt_attache.text_html(body,mt_attache.FLTK_ENCODING)
        else:
            payload = mt_attache.text_plain(body,mt_attache.FLTK_ENCODING)
        del body['Content-Type']
        body['Content-Type']="text/plain"
        del body['Content-Transfer-Encoding']
        body['Content-Transfer-Encoding']='8BIT'
        body.set_payload(payload)

        #Delete attachments etc.
        msg.set_payload([body])

        #Delete goofy headers
        for header in body.items():
            if header[0] not in ('Content-Type','MIME-Version'):
                del body[header[0]]
        
        #Quote ("With "> ") the previous body.
        body_to_quote = body.get_payload(decode=True)
        lines = body_to_quote.splitlines()
        lines = map(lambda x: "> "+x,lines)
        lines.insert(0,"On "+msg["Date"]+", "+oldfrom+" wrote:")
        body.set_payload("\n".join(lines)+"\n"+("-- \n"+signature+"\n" if signature!="" and body_to_quote.find(signature)==-1 else ""))
            
        #Update parent task on server
        nsync.node_update(self.get_stacktop_uidpath(),self.stack[-4][1].as_string())

    ##Load a file attachment to the clipboard
    # Always encoded as base64
    def load_file_to_clipboard(self):
        fname=fl_file_chooser("Select an attachment","*","")
        if fname==None:
            return 1
        try:
            filetext=open(fname).read()
        except IOError:
            fl_alert("No such file")
            return 1
        msg = email.message.Message()
        msg['Content-Type']=mt_utils.get_mime_type(fname)
        msg['Content-Transfer-Encoding']="base64"
        msg.add_header('Content-Disposition',"attachment",filename=(fname if fname.rfind("/")==-1 else fname[fname.rfind("/")+1:]))
        msg.set_payload(base64.b64encode(filetext))
        self.clipboard = ClientState.Clipboard(ClientState.Clipboard.SUBMESSAGE,msg)
        return 1

    ##Download an attachment
    def download_attachment(self):
        c_index = ui.main_browser.value()
        if not c_index or self.stack[-1][0]!=ClientState.ATTACHMENTS:
            return 1
        msg = nsync.cache["ATTACHMENTS"][c_index-1][1][None]
        
        fname = fl_file_chooser("Select a name for the download","*","")
        if fname==None:
            return 1
        try:
            output = os.fdopen(os.open(fname,os.O_WRONLY | os.O_CREAT),"w")
        except IOError:
            fl_alert("Failed to open specified file for writing")
        output.write(msg.get_payload(decode=True))
        return 1

    ##Create a new task.
    # This will not work unless you are in Task list view.
    def new_task(self):
        #In "task list" view
        if len(self.stack)==1 and self.stack[0][1]=="Tasks":
            newtask=email.message.Message()
            nt_body = email.message.Message()
            nt_body['Content-Type'] = "text/plain"
            nt_body.set_payload("")
            mt_utils.attach_payload(newtask,nt_body)
            newtask['Content-Type']="multipart/x.MailTask"
            newtask['Date']=email.utils.formatdate(localtime=True)
            newtask['Subject'] = "New Task"
            newtask['X-MailTask-Type'] = "Checklist"
            newtask['X-MailTask-Completion-Status'] = "Incomplete"
            newtask['X-MailTask-Virgin'] = "Yes"
            nsync.node_update("Tasks/NEWMESSAGE",newtask.as_string())
        else:
            fl_alert("Must be viewing Task list when creating new tasks.")
    
    ##Create new message
    def compose(self,accid):
        if ui.main_editor.visible():
            fl_alert("Cannot compose new message while editor active.")
            return 1

        #Create new draft message
        newmsg = email.message.Message()
        newmsg['Content-Type'] = "message/rfc822"
        newmsg['Content-Transfer-Encoding']='8BIT'
        newmsg['From'] = account_info[accid]

        #Create body for new draft message
        nm_body = email.message.Message()
        nm_body['Content-Type'] = "text/plain" #If you want HTML, repent your sins.
        nm_body.set_payload("-- \n"+signature if signature!="" else "")

        #Attach body to message
        newmsg.attach(nm_body)

        #Convenience hack: If we try to compose a message when we're not
        #in the DRAFTS view of a Task, put us in the BLACKHOLE task and
        #launch composition interface from there.
        if not (self.stack[0][1]=="Tasks" and self.stack[-1][0]==ClientState.DRAFTS):
            self.stack.append((ClientState.MESSAGE,email.parser.Parser().parse(open(os.path.join(cachedir,"Tasks/BLACKHOLE"))),"Tasks/BLACKHOLE"))
            self.stack.append((ClientState.DRAFTS,))

        #Put new message on stack, set us to view HEADERS first
        mt_utils.attach_payload(self.get_stacktop_msg(),newmsg)
        self.stack.append((ClientState.SUBMESSAGE,newmsg))
        self.stack.append((ClientState.HEADERS,))

        #Refresh screen
        ui.left_browser_callback(ui.left_browser,ClientUI.STACK_PUSHED)

    ##Toggle whether completed tasks are visible
    def toggle_completed_task_visibility(self):
        self.show_completed_tasks = not self.show_completed_tasks
        print "Show completed tasks: "+repr(self.show_completed_tasks)
        return 1

    ##Toggle forced completion status of task
    def toggle_current_task_completion(self):
        if len(self.stack)!=1 or self.stack[-1][1]!="Tasks" or not ui.main_browser.value():
            fl_alert("Force task completion not valid in this view.")

        msg = email.parser.Parser().parse(open(os.path.join(cachedir,self.stack[0][1],nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1]["UID"])))
        if 'X-MailTask-Forced-Complete' in msg:
            del msg['X-MailTask-Forced-Complete']
        else:
            msg['X-MailTask-Forced-Complete'] = "Yes"
        nsync.node_update(self.stack[0][1]+"/"+nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1]["UID"],msg.as_string())
        return 1

    ##Make task's time be now
    def nowify(self):
        if len(self.stack)!=1 or self.stack[-1][1]!="Tasks" or not ui.main_browser.value():
            fl_alert("Updating date field not allowed in this view.")

        msg = email.parser.Parser().parse(open(os.path.join(cachedir,self.stack[0][1],nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1]["UID"])))
        del msg['Date']
        msg['Date'] = email.utils.formatdate(localtime=True)
        nsync.node_update(self.stack[0][1]+"/"+nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1]["UID"],msg.as_string())
        return 1

    ##Rename an attachment
    def rename_attachment(self):
        if self.stack[-1][0]!=ClientState.ATTACHMENTS or not ui.main_browser.value():
            fl_alert("No attachment selected.")

        attach_obj = nsync.cache[self.stack[-1][1]][ui.main_browser.value()-1][1][None]
        newname = fl_input("Enter new name for attachment:",attach_obj.get_filename())
        if newname!=None:
            del attach_obj["Content-Disposition"]
            attach_obj.add_header("Content-Disposition","attachment",filename=newname)
    
    ##Update address book
    def update_addr_book_ui(self):
        nick=fl_input("Enter name of address book entry:")
        if nick==None:
            return 1
        current_val = addrbook_lookup(nick) if nick in address_book else ""
        newval = fl_input("Enter new value for address book entry "+nick,current_val)
        self.update_addr_book(nick,newval,True)
        return 1

    ##Update address book (internal)
    def update_addr_book(self,nick,newval,force=False):
        cur_time = time.time()
        if self.addrbook_rate_limit+1 > cur_time and not force:
            return 1
        self.addrbook_rate_limit = cur_time
        if newval!=None and newval!="":
            def mutator(old_val):
                #Do nothing if we're already in the address book
                if nick in address_book and newval in address_book[nick]:
                    return old_val

                old_addrbook = old_val.splitlines()
                old_nick_pos = mt_utils.find(old_addrbook,nick)

                #Check for duplicate addition to existing nick entry
                if old_nick_pos!=-1:
                    old_vals = set(old_addrbook[old_nick_pos+1].split(","))
                    if newval in old_vals:
                        return old_val

                #Check for cardinality one set containing newval
                if mt_utils.find(old_addrbook,newval)!=-1:
                    return old_val

                #Check if we'll be interfering with sender accounts
                if newval in map(get_email_addr_from_header,account_info):
                    return old_val

                #Perform the addition
                if nick not in address_book:
                    return old_val+nick+"\n"+newval+"\n"
                old_addrbook[old_addrbook.index(nick)+1]+=","+newval
                return "\n".join(old_addrbook)+"\n"
        elif nick in address_book:
            def mutator(old_val):
                old_addrbook = old_val.splitlines()
                idx = mt_utils.find(old_addrbook,nick)
                if idx==-1:
                    return old_val
                del old_addrbook[idx:(idx+2)]
                return "\n".join(old_addrbook)+"\n"
        else:
            return 1

        nsync.atomic_update("ADDRESSBOOK",mutator)
        return 1
    
    ##Use as handler for client keyboard shortcuts
    # Fl_event_key() and Fl_event_state() should be used to find out what shortcut
    @staticmethod
    def shortcut_handler(e_type):
        if e_type!=FL_SHORTCUT:
            return 0

        modified_event_state = Fl_event_state()&~FL_NUM_LOCK&~FL_SCROLL_LOCK&~FL_CAPS_LOCK

        #Notes:
        #- No message may be composed except if it is part of a task.
        #- For ease-of-use, support copying subject from message inside of a
        #  task to be the subject of the task itself.  This should be done
        #  when popping out of a task.
        #- Probably need get_stacktop_uid() function equivalent for message
        #  objects.
        
        valid_shortcuts = { (FL_CTRL,ord('e')) : c_state.toggle_editor,
                            (FL_CTRL,ord('w')) : c_state.cut_obj,
                            (FL_ALT,ord('w')) : c_state.copy_obj,
                            (FL_CTRL,ord('y')) : c_state.paste_obj,
                            (FL_CTRL,ord('k')) : c_state.delete_obj,
                            (0,FL_Escape) : c_state.pop_view,
                            (FL_CTRL,FL_Enter) : c_state.send_email,
                            (FL_CTRL|FL_ALT,ord('t')) : c_state.send_task,
                            (FL_CTRL,ord('r')) : c_state.make_reply_all,
                            (FL_CTRL,ord('j')) : c_state.make_reply_sender,
                            (FL_CTRL,ord('a')) : c_state.load_file_to_clipboard,
                            (FL_CTRL,ord('d')) : c_state.download_attachment,
                            (FL_CTRL,ord('n')) : c_state.new_task,
                            (FL_ALT,ord('v')) : c_state.toggle_completed_task_visibility,
                            (FL_ALT,ord('c')) : c_state.toggle_current_task_completion,
                            (FL_ALT,ord('r')) : c_state.rename_attachment,
                            (FL_ALT,ord('a')) : c_state.update_addr_book_ui,
                            (FL_ALT,ord('n')) : c_state.nowify }

        #These shortcuts go to the message composition interface.
        #Dynamically generated: Ctrl-0 uses account 0 as from, etc.
        for i in range(len(account_info)):
            valid_shortcuts[(FL_CTRL,ord(repr(i)))] = functools.partial(c_state.compose,i)

        if (modified_event_state,Fl_event_key()) not in valid_shortcuts:
            return 0

        #Switch based on event key, do your thing
        return valid_shortcuts[(modified_event_state,Fl_event_key())]()

class ClientNetSync:
   ##initialize nsync
   #NOTE: For all methods in queue, you must call flush afterwards
    def __init__(self):
        #Queue of server updates
        self.server_update_queue = deque()

        self.connmanager()

        ##UIDPaths of entities that we've modified; necessary to avoid feedback
        # loop due to reflections in mt_scrtry_rn.py and for quash warnings in client
        self.mirror = Counter()
        
        #In-memory cache of emails/tasks
        #In the "Tasks" folder, the value for the "UID" key is the
        #filename of the Task, which is a ctime-style timestamp.
        #There is a special "RELATED" key which holds a list
        #corresponding to the items in the "RELATED" view of an email.
        #It contains additional key "FOLDER".
        #There is a special "DRAFTS" key which holds a list
        #corresponding to the items in the "DRAFTS" view of a task.
        #It does not contain a UID key but contains the additional key
        #None, which is associated with a Message object representing
        #the entire draft email.
        #There is a special "ATTACHMENTS" key which holds a list
        #corresponding to the items in the "ATTACHMENTS" view of a task
        #or message.  It does not contain a UID key but contains the
        #additional key None, which is associated with a Message object
        #representing the attachment.
        #The items in the dictionary in the tuple in the array
        #attached to this key:
        #Format:
        # { "Account/Folder" :
        #    [ (Date, { "Header" : "value", "UID" : "value" }), ...] }
        #Each list is sorted in descending order by Date.  The date is
        #parsed from the email headers using email.utils.parsedate
        self.cache = {}

    ##Remove from mirror: return true if UID was in mirror, false otherwise
    def mirror_remove(self,uidpath):
        if not self.mirror[uidpath]:
            return False
        self.mirror[uidpath]-=1
        if self.mirror[uidpath]==0:
            del self.mirror[uidpath]
        return True

    ##initialize_cache: Send folder_update_req requests for all folders, including Tasks
    def initialize_cache(self):
        for i in range(len(account_info)):
            self.folder_update_req(repr(i)+"/INBOX")
            self.folder_update_req(repr(i)+"/Sent")
        self.folder_update_req("Tasks")

    ##add_to_cache: add a message or task to our local client cache, by default both in-memory and on-disk
    def add_to_cache(self,filename,contents,add_to_disk=True,deftime=0):
        if add_to_disk:
            open(os.path.join(cachedir,filename),'w').write(contents) #disk cache

        #Memory cache
        tokens = filename.rpartition('/') #tokens[0]==folder, tokens[2]==UID
        if tokens[0] not in self.cache:
            self.cache[tokens[0]]=[]
        msg = email.parser.Parser().parsestr(contents)
        msgdict = CaseInsensitiveDict(msg.items())
        msgdict["UID"] = tokens[2]
        msgtime = deftime
        if "Date" in msg:
            tztmt = email.utils.parsedate_tz(msg["Date"])
            if tztmt!=None:
                msgtime = email.utils.mktime_tz(tztmt)
        self.cache[tokens[0]].append((msgtime,msgdict))

        #Need to do special sorting for Tasks folder
        if tokens[0]!="Tasks":
            self.cache[tokens[0]].sort(key=lambda k: k[0],reverse=True) #inefficient
        else:
            def tasks_cmp(x,y):
                x_completed = 'X-MailTask-Completion-Status' in x[1] and x[1]['X-MailTask-Completion-Status']=="Completed"
                y_completed = 'X-MailTask-Completion-Status' in y[1] and y[1]['X-MailTask-Completion-Status']=="Completed"
                x_dinfo = 'X-MailTask-Date-Info' in x[1]
                y_dinfo = 'X-MailTask-Date-Info' in y[1]
                if x_completed and not y_completed:
                    return -1
                elif not x_completed and y_completed:
                    return 1
                elif x_dinfo and not y_dinfo:
                    return 1
                elif not x_dinfo and y_dinfo:
                    return -1
                elif x_dinfo: #and y_dinfo
                    xdate_ = email.utils.parsedate_tz(x[1]['X-MailTask-Date-Info'].split("/")[0].strip())
                    ydate_ = email.utils.parsedate_tz(y[1]['X-MailTask-Date-Info'].split("/")[0].strip())
                    xdate = email.utils.mktime_tz(xdate_) if xdate_!=None else 0
                    ydate = email.utils.mktime_tz(ydate_) if ydate_!=None else 0
                    return ydate-xdate
                else:
                    return x[0]-y[0]
            self.cache[tokens[0]].sort(cmp=tasks_cmp,reverse=True)

    ##remove_from_cache: remove a message or task from our local client cache, both in memory-and on-disk
    def remove_from_cache(self,filename):
        #Delete from memory cache
        tokens = filename.rpartition('/')
        flist = self.cache[tokens[0]]
        for i in range(len(flist)):
            if "UID" in flist[i][1] and flist[i][1]["UID"]==tokens[2]:
                del flist[i]
                break

        #Delete from disk
        try:
            os.remove(os.path.join(cachedir,filename))
        except OSError: #maybe our client.pickle was out of date
            pass
    
    ##fatal_error_cancel_connection: abruptly sever connections to server
    def fatal_error_cancel_connection(self):
        self.smessage_conn.write(OnTask_Message("FECC-OFF","").get_message_string())
        self.cmessage_conn.write(OnTask_Message("FECC-OFF","").get_message_string())

    ##cid_info: initialize client connection by sending our CID
    def cid_info(self,cid):
        def f_1():
            try:
                self.cmessage_conn.write(OnTask_Message("CID-INFO",cid).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    ack = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if ack.cmd_id=="ACK":
                        return None
                    raise IOError("Unexpected reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##node_update: update single node on server
    def node_update(self,update_filename,update_str):
        def f_1():
            try:
                body = update_filename+"\n"+repr(int(time.time()))+"\n"+update_str
                self.cmessage_conn.write(OnTask_Message("NODE-UPDATE",body).get_message_string())
                self.mirror[update_filename]+=1
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id=="ACK":
                        return None
                    elif reply.cmd_id=="NAK":
                        fl_alert("Warning: server preferred conflicting update.")
                        return None
                    else: #reply is probably "FECC-OFF"
                        raise IOError("Unexpected reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##send_email: instruct server to send an email
    def send_email(self,message):
        s_params = get_email_send_parameters_from_msg(message)
        accid = s_params[0]
        recipients = s_params[1]
        mt_utils.gen_message_id(message,s_params)
        message = mt_utils.unrfc822(message)
        message['User-Agent']=PROG_VERSION_STRING
        def f_1():
            try:
                body = accid+"\n"+",".join(recipients)+"\n"+message.as_string()
                self.cmessage_conn.write(OnTask_Message("SEND-EMAIL",body).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id!="ACK":
                        raise IOError("Unexpected reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)
        return message["Message-ID"]

    ##atomic_update: atomically update node on server
    # "mutator" parameter is callable that takes a single string and returns a string
    # It describes how the data received from the server should be atomically mutated
    def atomic_update(self,filename,mutator):
        def f_1(): #can't be called f_1: deadlock possible if it is
            global addrbook_update_time
            global addrbook_pong_received
            #Rate-limit addrbook updates so we don't screw things up
            if filename=="ADDRESSBOOK" and ( addrbook_update_time>=int(time.time()) or not addrbook_pong_received ):
                return f_1
            
            try:
                self.cmessage_conn.write(OnTask_Message("ATOMIC-UPDATE",filename).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                global addrbook_update_time
                global addrbook_pong_received
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id!="NODE-BODY-FULL":
                        raise IOError("Unexpected server reply")

                    updated_data = mutator(reply.body)
                    addrbook_update_time = int(time.time())
                    addrbook_pong_received=False
                    self.cmessage_conn.write(OnTask_Message("NODE-UPDATE",filename+"\n"+repr(addrbook_update_time)+"\n"+updated_data).get_message_string())
                    self.cmessage_conn.flush()
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id=="ACK":
                        return None
                    elif reply.cmd_id=="NAK":
                        fl_alert("Warning: server preferred conflicting update.")
                        addrbook_pong_received = True
                        return None
                    else: #reply is probably "FECC-OFF"
                        raise IOError("Unexpected reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##node_request: takes pathname of node requested
    def node_request(self,filename):
        def f_1():
            try:
                self.cmessage_conn.write(OnTask_Message("NODE-REQUEST",filename).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id!="NODE-BODY-FULL":
                        raise IOError("Unexpected server reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1

                #If we called this function, we must know we need the data from it in the cache somehow.
                self.add_to_cache(filename,reply.body,True,int(time.time()))
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##folder_update_req: takes name of folder to search
    def folder_update_req(self,folder_name):
        def f_1():
            try:
                self.cmessage_conn.write(OnTask_Message("FOLDER-UPDATE-REQ",folder_name).get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    reply = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if reply.cmd_id!="FOLDER-UPDATE-NOTIFY":
                        raise IOError("Unexpected server reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1

                #Now, we need to search this folder in our cache, delete files where the UID no longer exists, and queue up NODE-REQUESTs for cases where the file does not exist in our cache.
                local_path = os.path.join(cachedir,folder_name)
                cached_file_set = set(os.listdir(local_path))
                current_server_set = set(reply.body.split("\n")) if reply.body!="" else set()

                #Delete old local files, deleted on server
                for stale_item in cached_file_set.difference(current_server_set) if folder_name!="Tasks" or last_mod_time else cached_file_set:
                    self.remove_from_cache(folder_name+"/"+stale_item)

                #Add uncached new files, created on server
                for new_item in current_server_set.difference(cached_file_set) if folder_name!="Tasks" or last_mod_time else current_server_set:
                    self.node_request(folder_name+"/"+new_item)
                return None
            return f_2
        self.server_update_queue.append(f_1)

    ##Keepalive packets
    def keepalive_notify(self):
        def f_1():
            try:
                self.cmessage_conn.write(OnTask_Message("KEEPALIVE-NOTIFY","").get_message_string())
            except:
                self.fatal_error_cancel_connection()
                self.connmanager()
                return f_1

            def f_2():
                try:
                    ack = OnTask_Message.message_from_socket(self.cmessage_conn)
                    if ack.cmd_id!="ACK":
                        raise IOError("Unexpected server reply")
                except:
                    self.fatal_error_cancel_connection()
                    self.connmanager()
                    return f_1
                return None
            return f_2
        self.server_update_queue.append(f_1)
    
    ##Does not return until connection is successful
    def connmanager(self):
        ui.block_w.show()
        Fl_flush()

        connected = False
        while not connected:
            try:
                #Connect to server, set up client sockets

                #Clear update queue
                self.server_update_queue = deque()

                #Server socket
                self.smessage_conn = socket.socket()
                self.smessage_conn.connect((sys.argv[1],int(sys.argv[2])))
                self.smessage_conn_socket = self.smessage_conn
                self.smessage_conn = self.smessage_conn.makefile()

                #"HELLO" from server
                hello = OnTask_Message.message_from_socket(self.smessage_conn)
                if hello.cmd_id!="HELLO":
                    self.smessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.smessage_conn.close()
                    continue

                #Send password (yes, in the clear)
                self.smessage_conn.write(OnTask_Message("AUTHINFO",password).get_message_string())
                self.smessage_conn.flush()

                #"ACK" from server
                ack = OnTask_Message.message_from_socket(self.smessage_conn)
                if ack.cmd_id!="ACK":
                    self.smessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.smessage_conn.close()
                    continue

                #CID-REQUEST is next
                self.smessage_conn.write(OnTask_Message("CID-REQUEST",repr(last_mod_time) if last_mod_time else "").get_message_string())
                self.smessage_conn.flush()

                #"CID-NOTIFY" from server
                cid_message = OnTask_Message.message_from_socket(self.smessage_conn)
                if cid_message.cmd_id!="CID-NOTIFY":
                    self.smessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.smessage_conn.close()
                    continue

                #Now we have our CID
                cid = cid_message.body

                #ACK to the server
                self.smessage_conn.write(OnTask_Message("ACK","").get_message_string())
                self.smessage_conn.flush()

                #Open connection to client socket
                self.cmessage_conn = socket.socket()
                self.cmessage_conn.connect((sys.argv[1],int(sys.argv[3])))
                self.cmessage_conn_socket = self.cmessage_conn
                self.cmessage_conn = self.cmessage_conn.makefile()

                #Send CID, so server knows who we are
                #This must be done using queue: server may block otherwise
                self.cid_info(cid)
                connected = True

            except:
                try:
                    self.smessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.smessage_conn.close()
                except:
                    pass
                try:
                    self.cmessage_conn.write(OnTask_Message("FECC-OFF","Protocol error").get_message_string())
                    self.cmessage_conn.close()
                except:
                    pass

        ui.block_w.hide()
        Fl_flush()

##Update cache and send info to server
# Returns True if any messages processed, False otherwise
# nsync.server_update_queue is a deque of pending client socket communiques
def server_synchronize():
    global cachedir
    global last_mod_time
    
    #Have we processed any messages?
    messages_processed = False
    
    #select system call: I finally get to use this!
    retvals = select((nsync.smessage_conn_socket,nsync.cmessage_conn_socket),(nsync.cmessage_conn_socket,),(),0)

    #First: read from server notification socket if data is available
    #These are the possible server-initiated messages:
    #NODE-UPDATE-NOTIFY, CONNECT-STATUS-NOTIFY, FOLDER-INVALIDATE-NOTIFY,
    #KEEPALIVE-NOTIFY, and FECC-OFF.
    #We will ignore CONNECT-STATUS-NOTIFY.
    if nsync.smessage_conn_socket in retvals[0]:
        messages_processed = True
        smessage = OnTask_Message.message_from_socket(nsync.smessage_conn)
        if smessage.cmd_id=="NODE-UPDATE-NOTIFY":
            #Parse message body
            body = smessage.body
            uidpath = body[:body.index('\n')]
            modtime = int(body[(body.index('\n')+1):find_nth_substring('\n',2,body)])
            rfc822 = body[find_nth_substring('\n',2,body)+1:]

            mirror_flag = nsync.mirror_remove(uidpath)
            cacheadd_necessary = True

            #Special case the address book
            if uidpath=="ADDRESSBOOK":
                os.remove(os.path.join(cachedir,uidpath))
                open(os.path.join(cachedir,uidpath),'w').write(rfc822)
                initialize_addrbook()
                cacheadd_necessary = False
            
            #Add body to cache if necessary
            tokens = uidpath.rpartition('/')
            if tokens[0] in nsync.cache:
                for record in nsync.cache[tokens[0]]:
                    if record[1]["UID"]==tokens[2] and record[0] >= modtime:
                        cacheadd_necessary = False
                        break

            if cacheadd_necessary:
                try: #if file already exists, we need to remove it from our memory and disk caches
                    nsync.remove_from_cache(uidpath)
                except OSError:
                    pass
                if rfc822!="": #only add to cache if file would not be empty
                    if len(c_state.stack) > 1 and c_state.stack[1][0]==ClientState.MESSAGE and c_state.stack[1][2]==uidpath and not mirror_flag:
                        fl_alert("Warning: If you modify this task, your update will quash an update from the server you have not yet seen.  You are advised to escape back to the task list and discard any edits.")
                    nsync.add_to_cache(uidpath,rfc822,True,modtime)

            #Update last mod time
            last_mod_time = modtime

        elif smessage.cmd_id=="FOLDER-INVALIDATE-NOTIFY":
            #Delete all files in cached folder
            shutil.rmtree(os.path.join(cachedir,smessage.body)) #oh yeah this is secure yup
            os.mkdir(os.path.join(cachedir,smessage.body))
            
            #Clear entry in nsync.cache
            nsync.cache[smessage.body] = []
            
        elif smessage.cmd_id=="KEEPALIVE-NOTIFY":
            nsync.keepalive_notify()

        elif smessage.cmd_id=="FECC-OFF":
            #Disconnect/reconnect after notifying user of bug
            print "*CONNECTION FAILURE*: Server terminated connection and indicated protocol error:\n\n"+smessage.body
            nsync.connmanager()
            nsync.initialize_cache()

        #Send ACK message to server
        nsync.smessage_conn.write(OnTask_Message("ACK","").get_message_string())
        nsync.smessage_conn.flush()
        
    #Now, handle client-initiated messages through server_update_queue.
    if not len(nsync.server_update_queue):
        return messages_processed #No client-initiated messages if queue empty

    #Callables with f_1 in name only need cmessage_conn to be writeable.
    #f_2 (and others, theoretically) need cmessage_conn ready for reading.
    if repr(nsync.server_update_queue[0]).find("f_1")!=-1 and nsync.cmessage_conn_socket in retvals[1] or nsync.cmessage_conn_socket in retvals[0]:
        queued_cmessage_handler = nsync.server_update_queue.popleft()
        handler_retval = queued_cmessage_handler()
        nsync.cmessage_conn.flush()
        if handler_retval!=None:
            nsync.server_update_queue.appendleft(handler_retval)
        if handler_retval!=queued_cmessage_handler:
            messages_processed = True

    #Return whether we processed anything
    print "Update status:"
    print "addrbook_update_time: "+repr(addrbook_update_time)
    print "addrbook_pong_received: "+repr(addrbook_pong_received)
    print "len(nsync.server_update_queue): "+repr(len(nsync.server_update_queue))
    return messages_processed


def main():
    global cachedir
    global c_state
    global last_mod_time
    global password
    global signature
    global nsync
    global ui

    #Name of program and intro text
    print "MailTask Alpha: The Email Manager"
    print "(c) 2015 by Patrick Simmons"
    print
    print "This program is free software: you can redistribute it and/or modify"
    print "it under the terms of the GNU General Public License as published by"
    print "the Free Software Foundation, either version 3 of the License, or"
    print "(at your option) any later version."

    print "This program is distributed in the hope that it will be useful,"
    print "but WITHOUT ANY WARRANTY; without even the implied warranty of"
    print "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"
    print "GNU General Public License for more details."
    print
    print "Libraries used:"
    print "html2text (c) 2012 Aaron Swartz (GPLv3)"
    print "requests_structures.py (c) The Requests Project (original Apachev2; any modifications GPLv3)"
    print
    print "This program is dedicated to the memory of Aaron Swartz."
    
    #Socket Default Timeout
    socket.setdefaulttimeout(600)

    #Set up ClientState: keeps track of UI view stack
    c_state = ClientState()
    c_state.stack.append((ClientState.FOLDER,"Tasks")) #This will always exist.
    
    #Set up UI
    ui = ClientUI()
    ui.make_window()

    #Read cache
    cachedir = os.path.join(os.path.expanduser("~"),".mailtask_data")

    #Initialize account information
    initialize_account_info()

    #Initialize addressbook
    try:
        initialize_addrbook()
    except IOError: #for when ADDRESSBOOK doesn't exist
        pass
    
    #Read in settings
    settings_f = open(os.path.join(cachedir,"settings"))
    password = settings_f.readline().rstrip()
    try:
        last_mod_time = int(settings_f.readline().rstrip())
    except:
        print "WARNING: no mod time in settings file; using 1/1/1970."
        last_mod_time = 0

    #Read in signature
    if os.path.isfile(os.path.join(cachedir,"signature")):
        signature = open(os.path.join(cachedir,"signature")).read().rstrip()
    else:
        signature = ""

    #Initial connection to server
    nsync = ClientNetSync()

    #Initialize nsync.cache with accounts and files from cache.

    #Local function to add all files in a folder to cache
    def folder_cache_add(folder):
        nsync.cache[folder]=[]
        for fname in os.listdir(os.path.join(cachedir,folder)):
            nsync.add_to_cache(folder+"/"+fname,open(os.path.join(cachedir,folder+"/"+fname)).read(),False)

    #If we have a pickle, use it; otherwise, read in all emails and parse them (slow)
    if os.path.isfile(cachedir+"/client.pickle"):
        nsync.cache = cPickle.load(open(cachedir+"/client.pickle","rb"))
    else:
        #Add all account folders to cache
        for x in range(len(account_info)):
            folder_cache_add(repr(x)+"/INBOX")
            folder_cache_add(repr(x)+"/Sent")
        folder_cache_add("Tasks")

    #Run left_browser_callback with STACK_POPPED parameter to add initial values to left browser
    ui.left_browser_callback(ui.left_browser,ClientUI.STACK_PUSHED)
    
    #Initialize cache
    nsync.initialize_cache()

    #Sole thread runs GUI loop and updates cache from socket between wait() calls
    try:
        while ui.window.shown():
            Fl_wait(5 if len(nsync.server_update_queue) <= 2 else 0)
            
            #server_synchronize run repeatedly as long as something processed.
            #left_browser_callback should also be run if server_synchronize
            #did anything, but only once in the event it is run multiple times.
            run_lb_callback = False
            try:
                while server_synchronize():
                    run_lb_callback = True
                if run_lb_callback:
                    ui.left_browser_callback(ui.left_browser)
                    run_lb_callback = False
            except IOError:
                nsync.connmanager()
                nsync.initialize_cache()
    finally:
        #End of program.  Sign off.
        nsync.cmessage_conn.write(OnTask_Message("SIGN-OFF","").get_message_string())
        nsync.cmessage_conn.flush()

        #Backup our cache to a pickle
        cPickle.dump(nsync.cache,open(cachedir+"/client.pickle",'wb'),cPickle.HIGHEST_PROTOCOL)
        open(os.path.join(cachedir,"settings"),'w').write(password+"\n"+repr(last_mod_time)+"\n")

if __name__=="__main__":
    main()
